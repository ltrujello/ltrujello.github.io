
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../What%20are%20those%20Coherence%20Conditions%3F/">
      
      
        <link rel="next" href="../Braided%20and%20Symmetric%20Monoidal%20Categories/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.2">
    
    
      
        <title>7.4 Mac Lane's Coherence Theorem - Home</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.d451bc0e.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.a5377069.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="mydarkscheme" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#74-mac-lanes-coherence-theorem" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Home" class="md-header__button md-logo" aria-label="Home" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Home
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              7.4 Mac Lane's Coherence Theorem
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="mydarkscheme" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../" class="md-tabs__link">
          
  
  Category Theory

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../algebra/" class="md-tabs__link">
          
  
  Algebra Notes

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../associahedron/" class="md-tabs__link">
        
  
    
  
  Associahedron

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="https://ltrujello.github.io/Tikz-Python/" class="md-tabs__link">
        
  
    
  
  Tikz-Python

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="https://github.com/ltrujello/poly-rust" class="md-tabs__link">
        
  
    
  
  Poly-Rust

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Home" class="md-nav__button md-logo" aria-label="Home" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Home
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Category Theory
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Category Theory
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Categories, Functors and Natural Transformations.
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            Categories, Functors and Natural Transformations.
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Introduction%3A%20What%20are%20the%20Foundations%20of%20Math%3F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.1 Introduction: What are the Foundations of Math?
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Motivation%20for%20Category%20Theory/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.2 Motivation for Category Theory
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Category%20Theory%20Axioms./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.3 Category Theory Axioms.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Examples%20of%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.4 Examples of Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Paths%20and%20Diagrams%20in%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.5 Paths and Diagrams in Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Functors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.6 Functors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Examples%20and%20Nonexamples%20of%20Functors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.7 Examples and Nonexamples of Functors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Forgetful%2C%20Full%20and%20Faithful%20Functors./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.8 Forgetful, Full and Faithful Functors.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Natural%20Transformations/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.9 Natural Transformations
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Monic%2C%20Epics%2C%20and%20Isomorphisms/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.10 Monic, Epics, and Isomorphisms
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Categories%2C%20Functors%20and%20Natural%20Transformations./Initial%2C%20Terminal%2C%20and%20Zero%20Objects/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.11 Initial, Terminal, and Zero Objects
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Duality and Categorical Constructions
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            Duality and Categorical Constructions
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Duality%20and%20Categorical%20Constructions/%24%5Cmathcal%7BC/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.1 $\mathcal{C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Duality%20and%20Categorical%20Constructions/Products%20of%20Categories%2C%20Functors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.2 Products of Categories, Functors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Duality%20and%20Categorical%20Constructions/Functor%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.3 Functor Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Duality%20and%20Categorical%20Constructions/Vertical%2C%20Horizontal%20Composition%3B%20Interchange%20Laws/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.4 Vertical, Horizontal Composition; Interchange Laws
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Duality%20and%20Categorical%20Constructions/Slice%20and%20Comma%20Categories./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.5 Slice and Comma Categories.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Duality%20and%20Categorical%20Constructions/Graphs%2C%20Quivers%20and%20Free%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.6 Graphs, Quivers and Free Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Duality%20and%20Categorical%20Constructions/Quotient%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.7 Quotient Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Duality%20and%20Categorical%20Constructions/Monoids%2C%20Groups%20and%20Groupoids%20in%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.8 Monoids, Groups and Groupoids in Categories
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Universal Constructions and Limits
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_4">
            <span class="md-nav__icon md-icon"></span>
            Universal Constructions and Limits
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Universal%20Constructions%20and%20Limits/Universal%20Morphisms/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 Universal Morphisms
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Universal%20Constructions%20and%20Limits/Representable%20Functors%20and%20Yoneda%27s%20Lemma/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 Representable Functors and Yoneda's Lemma
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Universal%20Constructions%20and%20Limits/Finite%20Products/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 Finite Products
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Universal%20Constructions%20and%20Limits/Finite%20Coproducts/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 Finite Coproducts
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Universal%20Constructions%20and%20Limits/Arbitrary%20Products%20and%20Coproducts%20in%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 Arbitrary Products and Coproducts in Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Universal%20Constructions%20and%20Limits/Introduction%20to%20Limits%20and%20Colimits/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 Introduction to Limits and Colimits
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Universal%20Constructions%20and%20Limits/Equalizers%20and%20Coequalizers/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.7 Equalizers and Coequalizers
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Universal%20Constructions%20and%20Limits/Pullbacks%20and%20Pushouts/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.8 Pullbacks and Pushouts
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Adjunctions.
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5">
            <span class="md-nav__icon md-icon"></span>
            Adjunctions.
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Adjunctions./Introduction%20to%20Adjunctions./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.1 Introduction to Adjunctions.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Adjunctions./Reflective%20Subcategories./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.2 Reflective Subcategories.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Adjunctions./Equivalence%20of%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.3 Equivalence of Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Adjunctions./Adjoints%20on%20Preorders./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.4 Adjoints on Preorders.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Adjunctions./Exponential%20Objects%20and%20Cartesian%20Closed%20Categories./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4.5 Exponential Objects and Cartesian Closed Categories.
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_6" >
        
          
          <label class="md-nav__link" for="__nav_2_6" id="__nav_2_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Limits and Colimits.
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_6">
            <span class="md-nav__icon md-icon"></span>
            Limits and Colimits.
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Limits%20and%20Colimits./Every%20Limit%20in%20Set%3B%20Creation%20of%20Limits/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.1 Every Limit in Set; Creation of Limits
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Limits%20and%20Colimits./Inverse%20and%20Direct%20Limits./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.2 Inverse and Direct Limits.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Limits%20and%20Colimits./Limits%20from%20Products%2C%20Equalizers%2C%20and%20Pullbacks./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.3 Limits from Products, Equalizers, and Pullbacks.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Limits%20and%20Colimits./Preservation%20of%20Limits/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.4 Preservation of Limits
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Limits%20and%20Colimits./Adjoints%20on%20Limits/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.5 Adjoints on Limits
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Limits%20and%20Colimits./Existence%20of%20Universal%20Morphisms%20and%20Adjoint%20Functors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.6 Existence of Universal Morphisms and Adjoint Functors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Limits%20and%20Colimits./Subobjects%20and%20Quotient%20Objects/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5.7 Subobjects and Quotient Objects
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_7" >
        
          
          <label class="md-nav__link" for="__nav_2_7" id="__nav_2_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Filtered Colimits, Coends, and Kan Extensions
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_7">
            <span class="md-nav__icon md-icon"></span>
            Filtered Colimits, Coends, and Kan Extensions
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Filtered%20Colimits%2C%20Coends%2C%20and%20Kan%20Extensions/Filtered%20Categories%20and%20Limits/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6.1 Filtered Categories and Limits
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_8" checked>
        
          
          <label class="md-nav__link" for="__nav_2_8" id="__nav_2_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Monoidal Categories
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_8_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_8">
            <span class="md-nav__icon md-icon"></span>
            Monoidal Categories
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../Monoidal%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.1 Monoidal Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../Monoidal%20Functors/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.2 Monoidal Functors
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../What%20are%20those%20Coherence%20Conditions%3F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.3 What are those Coherence Conditions?
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    7.4 Mac Lane's Coherence Theorem
  </span>
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../Braided%20and%20Symmetric%20Monoidal%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.5 Braided and Symmetric Monoidal Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../Coherence%20for%20Braided%20Monoidal%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.6 Coherence for Braided Monoidal Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../Monoids%2C%20Groups%2C%20in%20Symmetric%20Monoidal%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.7 Monoids, Groups, in Symmetric Monoidal Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../Enriched%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7.8 Enriched Categories
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_9" >
        
          
          <label class="md-nav__link" for="__nav_2_9" id="__nav_2_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Abelian Categories
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_9">
            <span class="md-nav__icon md-icon"></span>
            Abelian Categories
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Abelian%20Categories/Preadditive%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.1 Preadditive Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Abelian%20Categories/Additive%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.2 Additive Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Abelian%20Categories/Preabelian%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.3 Preabelian Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Abelian%20Categories/Kernels%20and%20Cokernels/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.4 Kernels and Cokernels
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Abelian%20Categories/Abelian%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8.5 Abelian Categories
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_10" >
        
          
          <label class="md-nav__link" for="__nav_2_10" id="__nav_2_10_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Operads
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_10">
            <span class="md-nav__icon md-icon"></span>
            Operads
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Operads/Operads%20on%20Sets/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.1 Operads on Sets
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Operads/General%20Operads%20in%20Symmetric%20Monoidal%20Categories/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.2 General Operads in Symmetric Monoidal Categories
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Operads/Partial%20Composition%3A%20Restructuring%20Operads/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.3 Partial Composition: Restructuring Operads
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Operads/The%20Braid%20Groups%20Form%20a%20%28nonsymmetric%29%20Operad/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9.4 The Braid Groups Form a (nonsymmetric) Operad
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_11" >
        
          
          <label class="md-nav__link" for="__nav_2_11" id="__nav_2_11_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Sheaves
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_11">
            <span class="md-nav__icon md-icon"></span>
            Sheaves
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Sheaves/Topological%20Presheaves%20and%20Sheaves/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    10.1 Topological Presheaves and Sheaves
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Sheaves/Abstracting%20Sheaves/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    10.2 Abstracting Sheaves
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Sheaves/Stalks%20and%20Germs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    10.3 Stalks and Germs
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_12" >
        
          
          <label class="md-nav__link" for="__nav_2_12" id="__nav_2_12_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Persistence Modules
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_12">
            <span class="md-nav__icon md-icon"></span>
            Persistence Modules
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Persistence%20Modules/Persistence%20modules%20on%20%24%5Crr%24./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    11.1 Persistence modules on $\rr$.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Persistence%20Modules/Generalized%20Persistence%20Modules./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    11.2 Generalized Persistence Modules.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Persistence%20Modules/Interleaving%20Distances%20via%20Sublinear%20Projections%20and%20Superlinear%20Families/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    11.3 Interleaving Distances via Sublinear Projections and Superlinear Families
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Persistence%20Modules/General%20Persistence%20Diagrams/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    11.4 General Persistence Diagrams
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Algebra Notes
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Algebra Notes
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Groups
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            Groups
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Definitions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.1 Definitions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Permutation%20Groups./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.2 Permutation Groups.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Homomorphism%20and%20Isomorphisms./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.3 Homomorphism and Isomorphisms.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Cyclic%20Groups./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.4 Cyclic Groups.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Left%20and%20Right%20Cosets%2C%20Lagrange%27s%20Theorem/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.5 Left and Right Cosets, Lagrange's Theorem
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Normal%20subgroups/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.6 Normal subgroups
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Quotient%20Groups./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.7 Quotient Groups.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Isomorphism%20Theorems/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.8 Isomorphism Theorems
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Group%20Actions./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.9 Group Actions.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Conjugation%2C%20The%20Class%20Equation%2C%20and%20Cauchy%27s%20Theorem./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.10 Conjugation, The Class Equation, and Cauchy's Theorem.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Sylow%20Theorems./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.11 Sylow Theorems.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Groups/Fundamental%20Theorem%20of%20Finite%20Abelian%20Groups./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.12 Fundamental Theorem of Finite Abelian Groups.
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Rings
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            Rings
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Rings/Definitions./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.1 Definitions.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Rings/Ring%20homomorphisms./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.2 Ring homomorphisms.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Rings/Ideals%20and%20Quotient%20Rings./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.3 Ideals and Quotient Rings.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Rings/Isomorphism%20Theorems./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.4 Isomorphism Theorems.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Rings/Principal%2C%20Maximal%20and%20Prime%20Ideals./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.5 Principal, Maximal and Prime Ideals.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Rings/Ring%20of%20Fractions./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.6 Ring of Fractions.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Rings/PIDs%20and%20Euclidean%20Domains./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.7 PIDs and Euclidean Domains.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Rings/Polynomial%20Rings%20%28for%20Galois%20Theory%29./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2.8 Polynomial Rings (for Galois Theory).
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3_4" >
        
          
          <label class="md-nav__link" for="__nav_3_4" id="__nav_3_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Modules
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_4">
            <span class="md-nav__icon md-icon"></span>
            Modules
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Modules/Definitions./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.1 Definitions.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Modules/Submodules%2C%20Quotient%20Modules%20and%20Isomorphism%20Theorems./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.2 Submodules, Quotient Modules and Isomorphism Theorems.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Modules/Generating%20Modules%2C%20Torsions%2C%20Annihilators./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.3 Generating Modules, Torsions, Annihilators.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Modules/Cartesian%20Products%20and%20Direct%20Sums.%20/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.4 Cartesian Products and Direct Sums. 
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Modules/Exact%20Sequences%20and%20the%20Hom%20Functor./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.5 Exact Sequences and the Hom Functor.
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../algebra/Modules/Free%20%24R%24-modules./" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3.6 Free $R$-modules.
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../../associahedron/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Associahedron
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="https://ltrujello.github.io/Tikz-Python/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tikz-Python
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/ltrujello/poly-rust" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Poly-Rust
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<style>
.md-content {
    max-width: 80em;
}
</style>
<h1 id="74-mac-lanes-coherence-theorem">7.4. Mac Lane's Coherence Theorem</h1>
<p>\subsection*{Step One: Category of Binary Words}
To begin the proof of the coherence theorem, we need to first state 
the theorem itself. This task itself is quite laborious, although it is a worthwhile 
investment to establish clear terminology and notation, especially in writing the 
proof itself. Our primary tool will be the abstract concept of a binary 
word. </p>
<p><span style="display:block" class="definition">
Let <span class="arithmatex">\(x_0, x_1\)</span> be two distinct symbols. A <strong>binary word</strong> <span class="arithmatex">\(w\)</span> 
is an element defined recursively as follows.</p>
<ul>
<li><span class="arithmatex">\(x_0\)</span> and <span class="arithmatex">\(x_1\)</span> are binary words.</li>
<li>If <span class="arithmatex">\(u, v\)</span> are binary words, then <span class="arithmatex">\((u) \otimes (v)\)</span> is a binary word.</li>
</ul>
<p>More precisely, a binary word is any element in the 
free magma <span class="arithmatex">\(M = F(\{x_0,x_1\})\)</span> generated by <span class="arithmatex">\(x_0,x_1\)</span>, but we will see 
that the first definition we offered is more useful and transparent.
</span></p>
<p><span style="display:block" class="example">
Since <span class="arithmatex">\(x_0, x_1\)</span> are binary words so is the expression <span class="arithmatex">\((x_0)\otimes (x_1)\)</span>.
Similarly, the expressions </p>
<div class="arithmatex">\[
(x_0)\otimes((x_0)\otimes(x_1)) \quad ((x_0)\otimes(x_1))\otimes x_1   
\]</div>
<p>are binary words.
</span></p>
<p>From the previous example, we see that the notation is a bit clunky. 
On one hand, our definition, which states
that <span class="arithmatex">\((u)\otimes(v)\)</span> is a binary word if <span class="arithmatex">\(u,v\)</span> are, is required so that we can logically 
manage our parentheses. On the other, it makes notation clunky. </p>
<p>To remedy this, we will often omit parentheses. Given an expression of 
a binary word, we will always omit the parentheses around individual symbols in the 
expression. With this rule, we have that:</p>
<div class="arithmatex">\[\begin{gather*}
(x_0)\otimes (x_1) = x_0 \otimes x_1\\
(x_0)\otimes((x_0)\otimes(x_1))= x_0\otimes(x_0 \otimes x_1)\\
((x_0)\otimes(x_1))\otimes (x_1) = ( x_0\otimes x_1)\otimes x_1 
\end{gather*}\]</div>
<p>That is, we keep the parentheses which group together individual products, 
and throw away the ones which our smart human brains can don't need.</p>
<p>Next, we move onto an important quantity that we will often perform induction on.</p>
<p><span style="display:block" class="definition">
We define the <strong>length of a binary word</strong> <span class="arithmatex">\(w\)</span>, denoted as <span class="arithmatex">\(\mathcal{L}(w)\)</span>,
recursively as follows. </p>
<ul>
<li>sep-0.25em</li>
<li><span class="arithmatex">\(\mathcal{L}(x_0) = 0\)</span> and <span class="arithmatex">\(\mathcal{L}(x_1) = 1\)</span></li>
<li>If <span class="arithmatex">\(w=  u \otimes v\)</span> for two binary words <span class="arithmatex">\(u, v\)</span>, we set <span class="arithmatex">\(\mathcal{L}(w) = \mathcal{L}(u) + \mathcal{L}(v)\)</span>.</li>
</ul>
<p></span> </p>
<p><span style="display:block" class="example">
The binary words 
<span class="arithmatex">\((x_1\otimes x_0)\otimes x_1\)</span>, <span class="arithmatex">\((x_1\otimes x_1)\otimes x_0\)</span>, <span class="arithmatex">\((x_0 \otimes (x_1\otimes x_1))\otimes x_0\)</span>
all have length <span class="arithmatex">\(2\)</span>. 
</span></p>
<p>More informally, the length of binary word is simply the number of <span class="arithmatex">\(x_1\)</span> symbols that 
appear in its expression.  </p>
<p><span style="display:block" class="example">
For any binary word <span class="arithmatex">\(w\)</span>, we have that </p>
<div class="arithmatex">\[
\mathcal{L}(w \otimes x_0) = \mathcal{L}(x_0 \otimes w) =  \mathcal{L}(w).
\]</div>
<p>If additionally <span class="arithmatex">\(u,v\)</span> are binary words, we also have that </p>
<div class="arithmatex">\[\begin{align*}
\mathcal{L}(u \otimes(v \otimes  w)) 
&amp;= 
\mathcal{L}(u) + \left(\mathcal{L}(v) + \mathcal{L}(w)\right)\\
&amp;=
\left( \mathcal{L}(u) + \mathcal{L}(v) \right) + \mathcal{L}(w)\\
&amp;=
\mathcal{L}((u \otimes v) \otimes  w).
\end{align*}\]</div>
<p>We will use the observations made in the previous example later in this section.
</span></p>
<p>We now demonstrate that these binary words assemble into a category. </p>
<p><span style="display:block" class="definition">
The <strong>category of binary words</strong> is the category <span class="arithmatex">\(\mathcal{W}\)</span> where </p>
<ul>
<li><strong>Objects.</strong> All binary words <span class="arithmatex">\(w\)</span> of length <span class="arithmatex">\(n = 0, 1, 2, \dots,\)</span></li>
<li><strong>Morphisms.</strong> For any two binary words <span class="arithmatex">\(w\)</span> and <span class="arithmatex">\(v\)</span>, we have that </li>
</ul>
<div class="arithmatex">\[
\hom_{\ww}(v, w) = 
\begin{cases}
\{ \bullet \} &amp; \text{if } v,w \text{ are the same length}\\
\varnothing &amp; \text{otherwise}. 
\end{cases}   
\]</div>
<p>where <span class="arithmatex">\(\{\bullet\}\)</span> denotes the one point set.</p>
<p></span></p>
<p>What the above definition tells us is that any two binary words share 
a morphism if and only if they are of the same length. Moreover, they will only 
ever share <em>exactly one</em> morphism.
Since there is always at most one morphism between any two objects 
in <span class="arithmatex">\(\mathcal{W}\)</span>, we see that <span class="arithmatex">\(\mathcal{W}\)</span> is a \hyperref[definition:thin-category]{\textcolor{Blue}{thin category}}. 
Moreover, it is monoidal. To prove that it is monoidal, 
we will need the following small lemma. </p>
<p><span style="display:block" class="lemma">
The multiplication of binary words extends to a bifunctor 
<span class="arithmatex">\(\otimes: \ww \times \ww \to \ww\)</span>.
</span></p>
<p><span style="display:block" class="proof">
First, we explain how <span class="arithmatex">\(\otimes: \ww \times \ww \to \ww\)</span> operates on objects 
and morphisms.
If <span class="arithmatex">\((u, v)\)</span> is an object of <span class="arithmatex">\(\ww \times \ww\)</span>, we set <span class="arithmatex">\(\otimes(u, v) = u \otimes v\)</span>. 
Next, consider two morphisms in <span class="arithmatex">\(\ww\)</span>.</p>
<div class="arithmatex">\[
\gamma: u \to u' \qquad \beta: v \to v'.
\]</div>
<p>Note that this implies <span class="arithmatex">\(\ll(u) = \ll(u')\)</span> an <span class="arithmatex">\(\ll(v) = \ll(v')\)</span>, which 
also imply that </p>
<div class="arithmatex">\[
\ll(u \otimes v) = \ll(u) + \ll(v) = \ll(u') + \ll(v') = \ll(u' \otimes v').
\]</div>
<p>Therefore, we define the image of <span class="arithmatex">\((\gamma, \beta)\)</span> under the functor, <span class="arithmatex">\(\otimes(\gamma, \beta)\)</span>, which we more naturally denote 
as <span class="arithmatex">\(\gamma\otimes \beta\)</span>, to be the unique morphism between <span class="arithmatex">\(u \otimes v \to u' \otimes v'\)</span>.</p>
<p>We can picture the action of this functor on objects and morphisms more clearly as below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_0.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
In addition, for any <span class="arithmatex">\((u,v)\)</span> in <span class="arithmatex">\(\ww\times\ww\)</span>, the identity morphism <span class="arithmatex">\(1_{(u,v)}: (u,v) \to (u,v)\)</span> 
is mapped to the identity <span class="arithmatex">\(1_{u\otimes v} :u \otimes v \to u \otimes v\)</span>. 
Finally, to demonstrate that this respects composition, suppose that 
<span class="arithmatex">\((\gamma, \beta)\)</span> is composable with <span class="arithmatex">\((\gamma', \beta')\)</span>
as below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_1.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
As both <span class="arithmatex">\((\gamma', \beta')\otimes(\gamma, \beta)\)</span> and <span class="arithmatex">\((\gamma' \circ \gamma)\otimes (\beta' \circ \beta)\)</span>
are parallel morphisms acting as <span class="arithmatex">\((u_1,v_1) \to (u_3,  v_3)\)</span>, they must be equal 
because <span class="arithmatex">\(\ww\)</span> is a thin category (and hence parallel morphisms are equal).</p>
<p>Therefore, we see that <span class="arithmatex">\(\otimes: \ww \times \ww \to \ww\)</span> is a bifunctor.
</span></p>
<p>We now show that <span class="arithmatex">\(\ww\)</span> assembles into a monoidal category. </p>
<p><span style="display:block" class="proposition">
<span class="arithmatex">\((\ww, \otimes, x_0)\)</span> is a monoidal category
with monoidal product <span class="arithmatex">\(\otimes: \ww \times \ww \to \ww\)</span> <br />
and identity object <span class="arithmatex">\(x_0\)</span>.
</span></p>
<p><span style="display:block" class="proof">
First, we define our product to be given by the bifunctor <span class="arithmatex">\(\otimes: \ww\times\ww \to \ww\)</span>.
Second, we define our identity object to be <span class="arithmatex">\(x_0\)</span>. 
With these two conditions we now need to find unitors, an associator, and 
check that the necessary diagrams commute.</p>
<p>Now as any two binary words of the same length share a <em>unique</em> morphism,<br />
all morphisms are isomorphisms. Therefore, by Example \ref{example:binary_word_lengths},
the isomorphisms</p>
<div class="arithmatex">\[\begin{align*}
\alpha_{u,v,w}&amp;: u \otimes (v \otimes w) \isomarrow (u \otimes v) \otimes w\\
\lambda_w &amp;: x_0 \otimes w \isomarrow w\\
\rho_w &amp;: w \otimes x_0 \isomarrow w
\end{align*}\]</div>
<p>are forced to exist. Further, these isomorphisms are natural because all diagrams 
commute in a thin category. In addition, since <span class="arithmatex">\(\ww\)</span> is a thin category, 
all diagrams commute, and so, in particular, the required diagrams </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_2.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
also commute, so that <span class="arithmatex">\((\ww, \otimes, x_0)\)</span> satisfies the axioms of a monoidal category. 
</span>
We now make a few important comments on how to interpret <span class="arithmatex">\(\alpha, \rho\)</span>, and <span class="arithmatex">\(\lambda\)</span>.</p>
<ul>
<li>sep-0.25em</li>
<li>Each <span class="arithmatex">\(\alpha_{u,v,w}: u \otimes (v \otimes w) \to (u \otimes v) \otimes w\)</span> 
can be thought of as an operator which <strong>shifts</strong>  the parentheses to the left.
Dually, <span class="arithmatex">\(\alpha_{u,v,w}^{-1}\)</span> shift them to the right.</li>
<li>Each <span class="arithmatex">\(\lambda_w: x_0 \otimes w \isomarrow w\)</span> can be thought of as an operator 
that <strong>removes</strong> an identity from the left. Dually, <span class="arithmatex">\(\lambda_w^{-1}\)</span> adds an identity 
to the left.</li>
<li>Each <span class="arithmatex">\(\rho_w: w  \otimes x_0  \isomarrow w\)</span> can be thought of as an operator 
that <strong>removes</strong> an identity from the right. Dually, <span class="arithmatex">\(\rho^{-1}_w\)</span> adds 
an identity to the right.</li>
</ul>
<p>Hence, this very primitive monoidal category <span class="arithmatex">\(\ww\)</span> encodes some basic and 
useful operators on binary words.</p>
<p>\subsection*{Step Two: Pure Binary Words} 
In this section we begin discussing a specific subset of binary words, namely 
the ones which lack an identity <span class="arithmatex">\(x_0\)</span>.
As the theorem is quite complex, this initial restriction 
allows us to develop intuition and some tools that simplify the proof later.</p>
<p><span style="display:block" class="definition">
A <strong>pure binary word</strong> <span class="arithmatex">\(w\)</span> of length <span class="arithmatex">\(n\)</span> is a binary word <span class="arithmatex">\(w\)</span> of 
length <span class="arithmatex">\(n\)</span> which has no instance the empty word <span class="arithmatex">\(x_0\)</span>. 
</span></p>
<p><span style="display:block" class="example">
The only pure binary word of length 1 is <span class="arithmatex">\(x_1\)</span>. 
There is also only one pure binary word of length 2, which 
is <span class="arithmatex">\(x_1 \otimes x_1\)</span>.
The pure binary words of length 3 are 
\</p>
<div class="arithmatex">\[
x_1\otimes (x_1 \otimes x_1)
\qquad 
(x_1\otimes x_1) \otimes x_1
\]</div>
<p>and the pure binary words of length 4 are as below.</p>
<div class="arithmatex">\[\begin{gather*}
x_1\otimes(x_1\otimes (x_1 \otimes x_1))
\quad 
x_1\otimes((x_1\otimes x_1) \otimes x_1)
\quad 
((x_1\otimes x_1)\otimes x_1) \otimes x_1
\\
x_1\otimes((x_1 \otimes x_1) \otimes x_1)
\quad 
(x_1 \otimes (x_1 \otimes x_1))\otimes x_1
\end{gather*}\]</div>
<p></span></p>
<p>As a side note, we comment that the number of pure binary words of length <span class="arithmatex">\(n+1\)</span> is the
<span class="arithmatex">\(n\)</span>-th Catalan number </p>
<div class="arithmatex">\[
C_{n}=\frac{1}{n+1}{2n \choose n} \qquad 1,\, 2,\, 5,\, 14,\, 42,\, 132,\, 429,\, \cdots
\]</div>
<p>However, we make no critical use of this fact in our proofs.  <br />
Next, we form a category of pure binary words.</p>
<p><span style="display:block" class="definition">
The <strong>category of pure binary words</strong> <span class="arithmatex">\(\wp\)</span><br />
is the full subcategory of <span class="arithmatex">\(\ww\)</span> constructed by restricting 
the objects of <span class="arithmatex">\(\ww\)</span> to its pure binary words. </p>
<p>More explicitly, <span class="arithmatex">\(\wp\)</span> is the category defined as:</p>
<ul>
<li><strong>Objects.</strong> All pure binary words <span class="arithmatex">\(w\)</span> of length <span class="arithmatex">\(n = 0, 1, 2, \dots,\)</span></li>
<li><strong>Morphisms.</strong> For any two pure binary words <span class="arithmatex">\(u,v\)</span> of the same length, 
we have that <span class="arithmatex">\(\hom_{\ww_A}(u,v) = \{\bullet\}\)</span>, the one point set. 
No other morphisms are allowed.</li>
</ul>
<p></span></p>
<p>We now focus on a particular set of morphisms in <span class="arithmatex">\(\wp\)</span>. Recall that 
we may think of each <span class="arithmatex">\(\alpha_{u,w,v}\)</span> as a "shift map"</p>
<div class="arithmatex">\[
\alpha_{u,w,v}: u \otimes (v\otimes  w) \to (u \otimes v)\otimes w
\]</div>
<p>which makes a single change in the parenthesis of a binary word. 
However, <span class="arithmatex">\(\alpha\)</span> itself does not characterize all possible always in which we make
a single change of parentheses within a larger, more complex binary word.
An example of this is the morphism</p>
<div class="arithmatex">\[
1_{s}\otimes \alpha_{u,v,w}: s\otimes (u \otimes (v \otimes w))
\to s \otimes ((u \otimes v)\otimes w)
\]</div>
<p>which makes an <em>internal</em> change of parentheses. 
As we will need to focus on these more complicated morphisms, 
we rigorously define them below.</p>
<p><span style="display:block" class="definition">[<span class="arithmatex">\(\alpha\)</span>-arrows]<br />
A <span class="arithmatex">\(**forward ** \bm{\alpha}**-arrow**\)</span> of <span class="arithmatex">\(\wp\)</span> is a morphism in <span class="arithmatex">\(\wp\)</span> 
which we recursively define as follows. </p>
<ul>
<li>For any triple of pure binary words <span class="arithmatex">\(w_1, w_2, w_3\)</span> in <span class="arithmatex">\(\wp\)</span>, 
the morphism</li>
</ul>
<div class="arithmatex">\[
\alpha_{w_1,w_2,w_3}: w_1\otimes (w_2 \otimes w_3) \to (w_1\otimes w_2)\otimes w_3
\]</div>
<p>is a forward <span class="arithmatex">\(\alpha\)</span>-arrow.
* If <span class="arithmatex">\(\beta: w \to w'\)</span> is a forward 
<span class="arithmatex">\(\alpha\)</span>-arrow, and <span class="arithmatex">\(u\)</span> is an arbitrary pure binary word, 
then the morphisms </p>
<div class="arithmatex">\[
1_{u} \otimes \beta: u \otimes w \to u \otimes w' \qquad 
\beta \otimes 1_{u}:w \otimes u \to w' \otimes u
\]</div>
<p>are forward <span class="arithmatex">\(\alpha\)</span>-arrows.</p>
<p>We also define a **backward <span class="arithmatex">\(\bm{\alpha**\)</span>-arrow} to be the 
inverse of a forward <span class="arithmatex">\(\alpha\)</span>-arrow.
</span></p>
<p><span style="display:block" class="example">
Below are a few simple examples of <span class="arithmatex">\(\alpha\)</span>-arrows. The first two are forward, 
while the third is backward.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_3.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
We can have even more complicated examples; for example, the morphism below </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_4.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
is an <span class="arithmatex">\(\alpha\)</span>-morphism for any pure binary words <span class="arithmatex">\(u, v\)</span>. For example, setting 
<span class="arithmatex">\(u = (x_1 \otimes x_1)\otimes x_1\)</span> and <span class="arithmatex">\(v = x_1 \otimes x_1\)</span>, we obtain the forward <span class="arithmatex">\(\alpha\)</span>-arrow 
as below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_5.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
</span></p>
<p>We emphasize that <span class="arithmatex">\(\alpha\)</span>-arrows only ever involve a single 
instance of <span class="arithmatex">\(\alpha\)</span> or <span class="arithmatex">\(\alpha^{-1}\)</span> in their expression.</p>
<p>Next, we introduce a particularly important instance of a pure binary word that will 
become essential to our proof. </p>
<p><span style="display:block" class="definition">
We define the <strong>terminal word</strong> 
<span class="arithmatex">\(w^{(n)}\)</span> of length <span class="arithmatex">\(n\)</span> recursively as follows. </p>
<ul>
<li><span class="arithmatex">\(x_1\)</span> is the terminal word of length 1.</li>
<li>If <span class="arithmatex">\(w^{(k)}\)</span> is the terminal word of length <span class="arithmatex">\(k\)</span>, then 
<span class="arithmatex">\(w^{(k+1)} = w^{k}\otimes x_1\)</span> is the terminal word of length <span class="arithmatex">\(k+1\)</span>.</li>
</ul>
<p>More informally, the terminal word is the unique pure binary 
word of length <span class="arithmatex">\(n\)</span> for which all parentheses begin on the left.
</span> </p>
<p><span style="display:block" class="example">
Below we list the terminal words by length.
\begin{center}</p>
<p>|  Length |\multicolumn{1}{c|}{Terminal Word}|
|---------|----------------------------------|
| <span class="arithmatex">\(1\)</span> |<span class="arithmatex">\(x_1\)</span>|
|<span class="arithmatex">\(2\)</span> |<span class="arithmatex">\(x_1 \otimes x_1 <span class="arithmatex">\(|
|\)</span>3\)</span> |<span class="arithmatex">\((x_1 \otimes x_1)\otimes x_1 <span class="arithmatex">\(|
|\)</span>4\)</span> |<span class="arithmatex">\(((x_1 \otimes x_1)\otimes x_1)\otimes x_1 <span class="arithmatex">\(|
|\)</span>5\)</span> |<span class="arithmatex">\((((x_1 \otimes x_1)\otimes x_1)\otimes x_1)\otimes x_1\)</span>|
||</p>
<p>\end{center}
</span></p>
<p>We now introduce a quantity which provides a "distance-measure"
between a pure binary word of length <span class="arithmatex">\(n\)</span> and the terminal word <span class="arithmatex">\(w^{(n)}\)</span>.</p>
<p><span style="display:block" class="definition">
We (recursively) define 
the <strong>rank</strong> of a binary word as follows.</p>
<ul>
<li><span class="arithmatex">\(r(x_1) = 0\)</span>.</li>
<li>For a pure binary word of the form <span class="arithmatex">\(w = u \otimes v\)</span>, we set </li>
</ul>
<div class="arithmatex">\[
r(u\otimes v) = r(u) + r(v) + \ll(v) - 1.
\]</div>
<p></span></p>
<p><span style="display:block" class="example">
We compute the ranks on the pure binary words of length <span class="arithmatex">\(4\)</span>.</p>
<div class="arithmatex">\[\begin{align*}
&amp;r(x_1(x_1(x_1x_1))) =3
\qquad r(x_1((x_1x_1)x_1)) =2\\
&amp;r((x_1x_1)(x_1x_1)) =1
\qquad r((x_1(x_1x_1))x_1) =1\\
&amp;r(((x_1x_1)x_1)x_1) =0
\end{align*}\]</div>
<p></span></p>
<p>Note that <span class="arithmatex">\(w^{(4)} = ((x_1x_1)x_1)x_1\)</span> and <span class="arithmatex">\(r(((x_1x_1)x_1)x) = 0\)</span>. 
Hence we see that our intuition of the rank being a distance measure 
from <span class="arithmatex">\(w^{(n)}\)</span> so far makes sense. </p>
<p>An important property of distance-measuring 
functions is nonnegativity, which we will now see is satisfied by 
the rank function.</p>
<p><span style="display:block" class="lemma">
Let <span class="arithmatex">\(w\)</span> be a pure binary word of length <span class="arithmatex">\(n\)</span>. Then <span class="arithmatex">\(r(w) \ge 0\)</span>. 
</span></p>
<p><span style="display:block" class="proof">
We prove this by induction on <span class="arithmatex">\(n\)</span>.
First observe that this clearly holds for <span class="arithmatex">\(n = 0\)</span> since <span class="arithmatex">\(r(x_1) = 0\)</span>. </p>
<p>Now let <span class="arithmatex">\(w\)</span> be a pure binary word of length <span class="arithmatex">\(k\)</span>, and suppose the 
statement is true for all pure binary words with length less than <span class="arithmatex">\(k\)</span>.
Since <span class="arithmatex">\(k &gt; 1\)</span>, we may write <span class="arithmatex">\(w = u \otimes v\)</span> for some pure binary words 
<span class="arithmatex">\(u,v\)</span>, in which case </p>
<div class="arithmatex">\[
r(w) =  \overbrace{r(u) + r(v)}^{\ge 0 \text{ by induction}}
+ \ll(v) -1.
\]</div>
<p>Since <span class="arithmatex">\(\ll(v) \ge 1\)</span>, we see that <span class="arithmatex">\(r(w) \ge 0\)</span> as desired.
</span></p>
<p>Keeping with the analogy of the rank being a distance measure, we ought 
to verify that it is zero if and only if the input, which is being measured from 
<span class="arithmatex">\(w^{(n)}\)</span>, is <span class="arithmatex">\(w^{(n)}\)</span> itself. We verify that this is the case for the rank function.</p>
<p><span style="display:block" class="proposition">
Let <span class="arithmatex">\(w\)</span> be a pure binary word of length <span class="arithmatex">\(n\)</span>. 
Then <span class="arithmatex">\(r(w) = 0\)</span> if and only if <span class="arithmatex">\(w = w^{(n)}\)</span>.
</span></p>
<p><span style="display:block" class="proof">
We proceed by induction. In the simplest
case, when <span class="arithmatex">\(n = 1\)</span>, we have that
<span class="arithmatex">\(r(x_1) = 0\)</span> by definition. As <span class="arithmatex">\(x_1 = w^{(1)}\)</span>, we 
see that this satisfies the statement.</p>
<p>Let <span class="arithmatex">\(w\)</span> be a pure binary word of length <span class="arithmatex">\(k\)</span>, and suppose 
the statement is true for all pure binary words with length 
less than <span class="arithmatex">\(k\)</span>.
Then we may write our word in the form <span class="arithmatex">\(w = u \otimes v\)</span>, 
and we have that</p>
<div class="arithmatex">\[
r(w) = r(u) + r(v) + \ll(v) - 1.        
\]</div>
<p>By Lemma \ref{lemma:rank_is_positive}  we know that 
<span class="arithmatex">\(r(u), r(v) \ge 0\)</span>. Therefore, if <span class="arithmatex">\(\ll(v) &gt;  1\)</span> then 
<span class="arithmatex">\(r(w) \ne 0\)</span>. 
Hence, consider the case 
for when <span class="arithmatex">\(\ll(v) = 1\)</span>, so that <span class="arithmatex">\(v = x_1\)</span>. Then </p>
<div class="arithmatex">\[
r(u\otimes v) = r(u) + r(x_1) + \ll(x_1) - 1 = r(u)
\]</div>
<p>Therefore, <span class="arithmatex">\(r(w) = 0\)</span> if and only if
if <span class="arithmatex">\(r(u) = 0\)</span>. But by induction, this holds if and only if <span class="arithmatex">\(u = w^{(k-1)}\)</span>. 
So we see that <span class="arithmatex">\(w = w^{(k-1)}\otimes x_1 = w^{(k)}\)</span>, which proves our result for all <span class="arithmatex">\(n\)</span>.
</span></p>
<p><span style="display:block" class="lemma">
Let <span class="arithmatex">\(\beta: v \to w\)</span> be a forward <span class="arithmatex">\(\alpha\)</span>-arrow. 
Then <span class="arithmatex">\(r(v) &lt; r(w)\)</span>. In other words, forward <span class="arithmatex">\(\alpha\)</span>-arrows decrease rank. 
</span></p>
<p><span style="display:block" class="proof">
To demonstrate this, we perform induction on the structure of forward <span class="arithmatex">\(\alpha\)</span>-arrows. </p>
<p>Our base case is
<span class="arithmatex">\(\beta = \alpha_{u, v, w}: u\otimes(v\otimes w) \isomarrow (u\otimes v)\otimes w\)</span>
for some arbitrary words <span class="arithmatex">\(u, v, w\)</span>. With this case, observe that</p>
<div class="arithmatex">\[\begin{align*}
r(u\otimes(v\otimes w)) &amp; = r(u) + r(v \otimes w) + \ll(v\otimes w) - 1\\
&amp; = r(u) + (r(v) + r(w) + \ll(w) - 1)\\
&amp;+ \ll(v\otimes w) - 1
\end{align*}\]</div>
<p>while </p>
<div class="arithmatex">\[\begin{align*}
r((u\otimes v)\otimes w) &amp;= r(u\otimes v) + r(w) + \ll(w) - 1\\
&amp;= r(u) + r(v) + r(w) + \ll(v) - 1 + r(w) \\
&amp;+ \ll(w)- 1.
\end{align*}\]</div>
<p>If we subtract the quantities, we observe that </p>
<div class="arithmatex">\[
r(u\otimes(v\otimes w)) - r((u\otimes v)\otimes w) 
= \ll(v\otimes w) - \ll(w) &gt; 0
\]</div>
<p>since <span class="arithmatex">\(v\)</span> has at least length 1. Therefore <span class="arithmatex">\(\alpha_{u,v,w}\)</span> decreases 
length as desired.</p>
<p>Next, we reach our inductive step: let <span class="arithmatex">\(\beta = 1_{u} \otimes \gamma : u \otimes v \to u \otimes w\)</span> 
where <span class="arithmatex">\(\gamma: v \to w\)</span> is a forward  <span class="arithmatex">\(\alpha\)</span>-arrow
for which the statement is already true.</p>
<p>In this case we have that </p>
<div class="arithmatex">\[\begin{align*}
r(u\otimes v) = r(u) + r(v) + \ll(v) - 1.
\end{align*}\]</div>
<p>while </p>
<div class="arithmatex">\[\begin{align*}
r(u\otimes w) = r(u) + r(w) + \ll(w) - 1.
\end{align*}\]</div>
<p>Since <span class="arithmatex">\(\ll(v) = \ll(w)\)</span> and <span class="arithmatex">\(r(v) &gt; r(w)\)</span>, we see that 
<span class="arithmatex">\(r(u \otimes v) &gt; r(u \otimes w)\)</span>.
Therefore, we see that <span class="arithmatex">\(\beta = 1_u \otimes \gamma\)</span> decreases rank whenever 
<span class="arithmatex">\(\gamma\)</span> is a forward <span class="arithmatex">\(\alpha\)</span>-arrow that also decreases rank. </p>
<p>Finally, let <span class="arithmatex">\(\beta = \gamma \otimes 1_{u}\)</span> where <span class="arithmatex">\(\gamma: v \to w\)</span> 
is a forward <span class="arithmatex">\(\alpha\)</span> arrow for which the statement is already true. 
Then we may write <span class="arithmatex">\(\beta: v \otimes u \to w \otimes u\)</span> 
Now observe that </p>
<div class="arithmatex">\[
r(v \otimes  u) = r(v) + r(u) + \ll(u) - 1
\]</div>
<p>while </p>
<div class="arithmatex">\[
r(w \otimes  u) = r(w) + r(u) + \ll(u) - 1.
\]</div>
<p>Since <span class="arithmatex">\(\gamma: v \to w\)</span> decreases rank, we see that <span class="arithmatex">\(r(v) &gt; r(w)\)</span> and therefore
<span class="arithmatex">\(r(v \otimes u) &gt; r(w \otimes u)\)</span>, as desired. </p>
<p>This completes the proof by induction, so that the statement
is true for all forward <span class="arithmatex">\(\alpha\)</span>-arrows. 
</span></p>
<p>Thus what we have on our hands is the following. We know that the rank of word <span class="arithmatex">\(w\)</span>
is zero if and only if <span class="arithmatex">\(w = w^{(n)}\)</span>. Further, we know that applying <span class="arithmatex">\(\alpha\)</span>-arrows
to a pure binary word will decrease its rank. In other words, shifting the parentheses of a pure binary 
word <span class="arithmatex">\(w\)</span> brings <span class="arithmatex">\(w\)</span> "closer" to <span class="arithmatex">\(w^{(n)}\)</span> (whose parentheses are all on the left). 
Therefore, the rank of a pure binary word gives us a measure for how far 
a binary word <span class="arithmatex">\(w\)</span> is away from <span class="arithmatex">\(w^{(n)}\)</span>. </p>
<p>The following lemma demonstrates our interest in the word <span class="arithmatex">\(w^{(n)}\)</span>.</p>
<p><span style="display:block" class="proposition">
Let <span class="arithmatex">\(w\)</span> be a pure binary word of length <span class="arithmatex">\(n\)</span>. If <span class="arithmatex">\(w \ne w^{(n)}\)</span>, 
then there exists a finite sequence of forward
<span class="arithmatex">\(\alpha\)</span>-arrows from <span class="arithmatex">\(w\)</span> to <span class="arithmatex">\(w^{(n)}\)</span>. </p>
<p></span></p>
<p><span style="display:block" class="proof">
We first show that for every pure binary 
word <span class="arithmatex">\(w \ne w^{(n)}\)</span> there exists a forward <span class="arithmatex">\(\alpha\)</span>-arrow 
<span class="arithmatex">\(\beta\)</span> with domain <span class="arithmatex">\(w\)</span>.
We prove this statement by induction on length.</p>
<p>Observe the result is immediate for <span class="arithmatex">\(n = 1, 2\)</span>.
Suppose the result is true for 
binary words with length less than <span class="arithmatex">\(n \ge 3\)</span>. 
Let <span class="arithmatex">\(w\)</span> be a pure binary word with length <span class="arithmatex">\(n\)</span>. 
Then <span class="arithmatex">\(w = u \otimes v\)</span>, with <span class="arithmatex">\(u,v\)</span> other pure binary words. 
We now consider two cases for <span class="arithmatex">\(u\)</span> and <span class="arithmatex">\(v\)</span>.</p>
<ul>
<li><strong>(1)</strong> The first case is when  <span class="arithmatex">\(\ll(v) = 1\)</span>, so that <span class="arithmatex">\(v = x_1\)</span>. 
As <span class="arithmatex">\(w \ne w^{(n)}\)</span> we know that <span class="arithmatex">\(u \ne w^{(n-1)}\)</span>,
and since <span class="arithmatex">\(u\)</span> has 
length less than <span class="arithmatex">\(w\)</span>, we see that by induction there exists a forward <span class="arithmatex">\(\alpha\)</span>-arrow 
<span class="arithmatex">\(\beta: u \to u'\)</span>. Using <span class="arithmatex">\(\beta\)</span>, we can construct the 
forward <span class="arithmatex">\(\alpha\)</span>-arrow </li>
</ul>
<div class="arithmatex">\[
\beta \otimes 1_{x_1}: u \otimes x_1 \to u' \otimes x_1.  
\]</div>
<p>Hence <span class="arithmatex">\(\beta \otimes 1_{x_1}\)</span> is our desired forward <span class="arithmatex">\(\alpha\)</span>-arrow with domain <span class="arithmatex">\(w\)</span>.
* <strong>(2)</strong> The second case is when <span class="arithmatex">\(\ll(v) &gt; 1\)</span>. In this case we may write 
<span class="arithmatex">\(w = u \otimes (r \otimes s)\)</span>. A natural choice for a forward 
<span class="arithmatex">\(\alpha\)</span>-arrow in this case is simply </p>
<div class="arithmatex">\[
\alpha_{u,v,s}:  u \otimes (r \otimes s) \to (u \otimes r) \otimes s
\]</div>
<p>so that this case is also satisfied.</p>
<p>As we see, in all cases for <span class="arithmatex">\(w \ne w^{(n)}\)</span>, we can find a forward <span class="arithmatex">\(\alpha\)</span>-arrow 
with domain <span class="arithmatex">\(w\)</span>. As <span class="arithmatex">\(\alpha\)</span>-arrows decrease rank, and <span class="arithmatex">\(r(w) = 0\)</span> if and only if <span class="arithmatex">\(w^{(n)}\)</span>,
this guarantees a sequence of <span class="arithmatex">\(\alpha\)</span>-arrows from <span class="arithmatex">\(w\)</span> to <span class="arithmatex">\(w^{(n)}\)</span>, which is what 
we set out to show.
</span></p>
<p>The previous proposition has an immediate, useful corollary. 
It will be used as one of the building blocks for the next section. </p>
<p><span style="display:block" class="corollary">
Every morphism in <span class="arithmatex">\(\wp\)</span> can be expressed as a finite composition 
of <span class="arithmatex">\(\alpha\)</span>-arrows.
</span></p>
<p><span style="display:block" class="proof">
Let <span class="arithmatex">\(v, w\)</span> be arbitrary pure binary words. Denote <span class="arithmatex">\(\phi_{v,w}: v \to w\)</span> to be 
the unique morphism from <span class="arithmatex">\(v\)</span> to <span class="arithmatex">\(w\)</span>. By Proposition \ref{proposition_existence_of_w_to_wn}
there exists chains of forward <span class="arithmatex">\(\alpha\)</span>-arrows whose composite 
we denote as <span class="arithmatex">\(\Gamma_1: v \to w^{(n)}, \Gamma_2: w \to w^{(n)}\)</span>. Our situation is pictured
below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_6.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
However, <span class="arithmatex">\(\wp\)</span> is a thin category, so parallel morphisms must be equal. Therefore</p>
<div class="arithmatex">\[
\phi_{v,w} = \Gamma_2^{-1} \circ \Gamma_1.
\]</div>
<p>Hence <span class="arithmatex">\(\phi_{v,w}\)</span> is a composition of <span class="arithmatex">\(\alpha\)</span>-arrows. As <span class="arithmatex">\(\phi_{v,w}\)</span> 
was arbitrary, we see that every morphism in <span class="arithmatex">\(\wp\)</span> 
is a finite composition of <span class="arithmatex">\(\alpha\)</span>-arrows.
</span>
What this corollary says is that every morphism in <span class="arithmatex">\(\wp\)</span> can be expressed as a
composite of forward and backward <span class="arithmatex">\(\alpha\)</span>-arrows. However, we emphasize that 
there can be many different ways to represent a morphism in <span class="arithmatex">\(\wp\)</span> via 
<span class="arithmatex">\(\alpha\)</span>-arrows. This will be an issue which we discuss later in the next section.</p>
<p>\subsection*{Step Three: Coherence for <span class="arithmatex">\(A^{\otimes n}\)</span> in <span class="arithmatex">\(\alpha\)</span>}
Using our results from the previous section, we are almost ready to 
take our first major step in the proof of Mac Lane's Coherence 
Theorem. Before we do so, we need to introduce terminology to even state the theorem which we will prove in this section. 
Towards that goal we introduce a few more definitions. </p>
<p><span style="display:block" class="definition">
Let <span class="arithmatex">\((\mathcal{M}, \alpha, \lambda, \rho, I, \otimes)\)</span> be a monoidal 
category. For an object <span class="arithmatex">\(A\)</span> of <span class="arithmatex">\(\mm\)</span>, we 
define the <strong>proxy map</strong> of <span class="arithmatex">\(A\)</span> to be a <em>partial</em> functor</p>
<div class="arithmatex">\[
(-)_A: \wp \to \mm
\]</div>
<p>as follows. Note by <em>partial</em> functor, we mean a functor defined on all objects 
of <span class="arithmatex">\(\wp\)</span>, but only a subset of all morphisms of <span class="arithmatex">\(\wp\)</span>. </p>
<ul>
<li>
<p><strong>Objects.</strong> We define the action on objects recursively as follows.</p>
<ul>
<li>We set <span class="arithmatex">\((x_1)_A
= A\)</span>.</li>
<li>For a binary word <span class="arithmatex">\(w = u \otimes v\)</span>, we define </li>
</ul>
<p>$$
(w)_A
=
(u\otimes  v)_A
= 
(u)_A \otimes (v)_A
$$
* <strong>Morphisms.</strong> We define the partial functor only on 
<span class="arithmatex">\(\alpha\)</span>-arrows. We do this recursively as follows.
* For <span class="arithmatex">\(\alpha_{u,v,w}\)</span> with <span class="arithmatex">\(u,v,w\)</span> as pure binary words,
we set:</p>
<p>\begin{align<em>}
(\alpha_{u,v,w})<em>A &amp;= \alpha</em>{(u)<em>A,(v)_A,(w)_A}\
(\alpha^{-1}</em>{u,v,w})<em>A &amp;= \alpha^{-1}</em>{(u)_A,(v)_A,(w)_A}
\end{align</em>}
* For <span class="arithmatex">\(1_{u} \otimes \beta\)</span> 
and <span class="arithmatex">\(\beta \otimes 1_{u}\)</span> with <span class="arithmatex">\(\beta\)</span> an <span class="arithmatex">\(\alpha\)</span>-arrow, we set:</p>
<div class="arithmatex">\[\begin{align*}
&amp;(1_{u} \otimes \beta)_A = 1_{(u)_A} \otimes (\beta)_A\\ 
&amp;(\beta \otimes 1_{u})_A = (\beta)_A\otimes 1_{(u)_A}
\end{align*}\]</div>
</li>
</ul>
<p></span></p>
<p>We now introduce the theorem of the section. This theorem is the first major 
step in the proof of the coherence theorem, and the  rest of this section will 
be dedicated to proving it. </p>
<p><span style="display:block" class="theorem">[Coherence in <span class="arithmatex">\(\alpha\)</span>.]
Let <span class="arithmatex">\((\mm, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category. 
For every object <span class="arithmatex">\(A\)</span>, there exists a unique functor 
<span class="arithmatex">\(\Phi_A: \ww_P \to \mm\)</span> which restricts to the proxy map 
<span class="arithmatex">\((-)_A\)</span> on objects and <span class="arithmatex">\(\alpha\)</span>-arrows of <span class="arithmatex">\(\wp\)</span>. 
</span></p>
<p>We address the question the reader most likely has in mind right now: 
Why did we only define the proxy map on <span class="arithmatex">\(\alpha\)</span>-arrows? Why  not 
define it on all of the morphisms of <span class="arithmatex">\(\wp\)</span> to get a 
functor to begin with? 
We did this to avoid a potential well-definedness issue, which we 
now elaborate on.</p>
<p>Let us attempt to naturally extend the proxy map to a functor.
With Corollary \ref{corollary:morphisms_of_wp}, it is
clear how to proceed on 
defining <span class="arithmatex">\((-)_A\)</span> on general morphisms. 
Let  <span class="arithmatex">\(\gamma: v \to w\)</span> be any morphism in <span class="arithmatex">\(\wp\)</span>. 
By Corollary \ref{corollary:morphisms_of_wp}, 
there exist forward and backward <span class="arithmatex">\(\alpha\)</span>-arrows 
<span class="arithmatex">\(\gamma_1, \dots, \gamma_n\)</span> such  that  </p>
<div class="arithmatex">\[
\gamma = \gamma_n \circ \cdots \circ \gamma_1.
\]</div>
<p>Since the proxy map is in fact defined on <span class="arithmatex">\(\alpha\)</span>-arrows, and since 
functors preserve composition,
we are required to define</p>
<div class="arithmatex">\[
(\gamma)_A = (\gamma_n)_A\circ \cdots \circ (\gamma_1)_A.
\]</div>
<p>However, we need to be careful. Suppose that we can also 
express <span class="arithmatex">\(\gamma\)</span> as the finite composition of <span class="arithmatex">\(\alpha\)</span>-morphisms 
<span class="arithmatex">\(\delta_1, \dots , \delta_m\)</span>.</p>
<div class="arithmatex">\[
\gamma = \delta_m \circ \cdots \circ \delta_1.
\]</div>
<p>While <span class="arithmatex">\(\gamma_n \circ \cdots \circ \gamma_1 = \delta_m \circ \cdots \circ \delta_1\)</span> 
because <span class="arithmatex">\(\wp\)</span> is a thin category, and therefore parallel morphisms are equal, 
we have no idea if </p>
<div class="arithmatex">\[
(\gamma_n)_A\circ \cdots \circ (\gamma_1)_A
=
(\delta_m)_A\circ \cdots \circ (\delta_1)_A
\]</div>
<p>is true in <span class="arithmatex">\(\mm\)</span>. That is, we do not know if equivalent morphisms 
in <span class="arithmatex">\(\wp\)</span> are mapped to equal morphisms under the proxy map.
Our issue is one of well-definedness. </p>
<p>This issue is similar to one which
arises in group theory. When one attempts to define a group homomorphism on a 
quotient group, they must understand that there are different,
equivalent ways to represent an element. In this situation 
they must make sure that the equivalent elements are mapped to the same target 
in the codomain.</p>
<p><span style="display:block" class="example">
To illustrate our point, we include a concrete example of our 
problem which also demonstrates its nontriviality. 
For notational convenience, we suppress the instances of the monoidal product <span class="arithmatex">\(\otimes\)</span>.
Let</p>
<div class="arithmatex">\[
\gamma: x_1 ((x_1  x_1)  (x_1  x_1))
\to 
((x_1 (x_1  x_1)) x_1)  x_1.
\]</div>
<p>Then we have many possible ways of expressing <span class="arithmatex">\(\gamma\)</span> in terms of 
our <span class="arithmatex">\(\alpha\)</span>-arrows. Some potential ways we could express <span class="arithmatex">\(\gamma\)</span> are displayed 
below in \textcolor{Purple}{purple}, \textcolor{NavyBlue}{blue}, or \textcolor{Orange}{orange}.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_7.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
As this is a thin category, we know that the composition of these paths 
are equal in <span class="arithmatex">\(\wp\)</span>. 
However, we now have many ways to define <span class="arithmatex">\(\gamma\)</span> under the proxy map <span class="arithmatex">\((-)_A\)</span>. 
We could write</p>
<div class="arithmatex">\[\begin{align*}  
(\gamma)_A &amp;= 
(\textcolor{Purple}{(\alpha^{-1}_{x_1,x_1,x_1}\otimes  1_{x_1})
\otimes 1_{x_1}})_A \circ \cdots \circ 
(\textcolor{Purple}{1_{x_1}\otimes \alpha_{x_1x_1, x_1, x_1}})_A
\\
&amp;=\textcolor{Purple}{(\alpha^{-1}_{A,A,A}\otimes  1_{A})\otimes 1_{A}} \circ \cdots \circ \textcolor{Purple}{1_{A}\otimes \alpha_{AA, A, A}}
\end{align*}\]</div>
<p>or </p>
<div class="arithmatex">\[\begin{align*}
(\gamma)_A &amp;= 
(\textcolor{NavyBlue}{\alpha_{x_1, x_1x_1, x_1}\otimes 1_{x_1}})_A
\circ \cdots \circ 
(\textcolor{NavyBlue}{1_{x_1}\otimes \alpha_{x_1x_1, x_1, x_1}})_A\\
&amp;= 
\textcolor{NavyBlue}{\alpha_{A, AA, A}\otimes 1_{A}}
\circ \cdots \circ \textcolor{NavyBlue}{1_{A}\otimes \alpha_{AA, A, A}}
\end{align*}\]</div>
<p>or</p>
<div class="arithmatex">\[\begin{align*}
(\gamma)_A &amp;= 
(\textcolor{Orange}{\alpha_{x_1(x_1x_1),x_1, x_1}})_A\circ
(\textcolor{Orange}{\alpha_{x_1, x_1x_1, x_1x_1}})_A\\
&amp;=
\textcolor{Orange}{\alpha_{A(AA),A, A}} \circ \textcolor{Orange}{\alpha_{A, AA, AA}}
\end{align*}\]</div>
<p>But as morphisms in <span class="arithmatex">\(\mm\)</span>, we don't know if 
these compositions in <span class="arithmatex">\(\mm\)</span>, displayed below, are all equal.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_8.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
Hence we need to show that the \textcolor{Purple}{purple}, \textcolor{NavyBlue}{blue}, and \textcolor{Orange}{orange} compositions
are equal in <span class="arithmatex">\(\mm\)</span>. While we could perform tedious diagram chases to show that they  are 
equal in <span class="arithmatex">\(\mm\)</span>, that would only address three of the many possible ways to express 
<span class="arithmatex">\(\gamma\)</span>. It also would not take care of the case for much larger binary words! 
Hence, this problem is very nontrivial in general; we need higher level techniques to get 
what we want. 
</span></p>
<p>Therefore, to define a functor in the first place, we need to prove the following 
fact. </p>
<p><span style="display:block" class="proposition">
Let <span class="arithmatex">\((\mathcal{M}, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category, 
and let <span class="arithmatex">\(A\)</span> be an object of <span class="arithmatex">\(\mm\)</span>. Let <span class="arithmatex">\(v,w\)</span> be binary words of the same length.
If <span class="arithmatex">\(\beta_1, \dots , \beta_k\)</span> and <span class="arithmatex">\(\gamma_1, \dots , \gamma_{\ell}\)</span> are 
<span class="arithmatex">\(\alpha\)</span>-arrows with </p>
<div class="arithmatex">\[
\beta_k \circ \cdots \circ \beta_1,
\gamma_{\ell} \circ \cdots \circ \gamma_1: v \to w
\]</div>
<p>then <span class="arithmatex">\((\beta_k)_A  \circ \cdots \circ (\beta_1)_A
= (\gamma_{\ell})_A \circ \cdots \circ (\gamma_1)_A\)</span> in <span class="arithmatex">\(\mm\)</span>.
</span></p>
<p>To prove this proposition, we will see that it actually suffices to prove 
the the special case with <span class="arithmatex">\(w = w^{(n)}\)</span> and with <span class="arithmatex">\(\beta_1, \dots , \beta_{k}\)</span> and <span class="arithmatex">\(\gamma_1, \dots , \gamma_{\ell}\)</span>
all <em>forward</em> <span class="arithmatex">\(\alpha\)</span>-arrows. That is, it suffices to prove the following proposition. </p>
<p><span style="display:block" class="proposition">
Let <span class="arithmatex">\((\mathcal{M}, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category, 
and let <span class="arithmatex">\(A\)</span> be an object of <span class="arithmatex">\(\mm\)</span>. Let <span class="arithmatex">\(w\)</span> be a pure binary word of length <span class="arithmatex">\(n\)</span>.
If <span class="arithmatex">\(\beta_1, \dots , \beta_k\)</span> and <span class="arithmatex">\(\gamma_1, \dots , \gamma_{\ell}\)</span> are 
forward <span class="arithmatex">\(\alpha\)</span>-arrows with </p>
<div class="arithmatex">\[
\beta_k \circ \cdots \circ \beta_1,
\gamma_{\ell} \circ \cdots \circ \gamma_1: w \to w^{(n)}
\]</div>
<p>in <span class="arithmatex">\(\wp\)</span>, then <span class="arithmatex">\((\beta_k)_A  \circ \cdots \circ (\beta_1)_A
= (\gamma_{\ell})_A \circ \cdots \circ (\gamma_1)_A\)</span> in <span class="arithmatex">\(\mm\)</span>.
</span></p>
<p>To prove this it will suffice to prove the Diamond Lemma (stated below).
It will turn out the bulk of the overall proof toward our theorem will be 
spent on the Diamond Lemma. At the risk of downplaying its importance, 
we leave the proof of the Diamond Lemma to the end since 
it is very tedious and involved, and we do not want to 
disrupt the flow of the current discussion.</p>
<p>We summarize our plan on how to prove Theorem \ref{theorem:coherence_in_alpha}.
The uncolored boxes, and the implications between them,
are what is left to do.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_9.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/></p>
<p><span style="display:block" class="lemma">[Diamond Lemma]
Let <span class="arithmatex">\(w\)</span> be a pure binary word and suppose <span class="arithmatex">\(\beta_1,\beta_2\)</span> are two 
forward <span class="arithmatex">\(\alpha\)</span>-arrows as below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_10.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
There exists a pure binary word <span class="arithmatex">\(z\)</span> and two <span class="arithmatex">\(\gamma_1: w_1 \to z, \gamma_2: w_2 \to z\)</span>,
with <span class="arithmatex">\(\gamma_1, \gamma_2\)</span> a composition of forward <span class="arithmatex">\(\alpha\)</span>-arrows,
such that for any monoidal category 
<span class="arithmatex">\((\mm, \otimes, I, \alpha, \lambda, \rho)\)</span> the diagram below is 
commutative in <span class="arithmatex">\(\mm\)</span>.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_11.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/></p>
<p></span></p>
<p>Since the above lemma is an existence result, 
we emphasize this fact by coloring 
the arrows, which we are asserting to exist, Green. 
This is a practice we will continue.</p>
<p>As promised, we now prove Proposition \ref{proposition:parallel_w_to_wn_equal_in_M} 
using the Diamond lemma. We restate the statement of the proposition for the reader's 
convenience.</p>
<p>\begin{customprop}{\ref{proposition:parallel_w_to_wn_equal_in_M}}
Let <span class="arithmatex">\((\mathcal{M}, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category, 
and let <span class="arithmatex">\(A\)</span> be an object of <span class="arithmatex">\(\mm\)</span>. Let <span class="arithmatex">\(w\)</span> be a pure binary word of length <span class="arithmatex">\(n\)</span>.
If <span class="arithmatex">\(\beta_1, \dots , \beta_k\)</span> and <span class="arithmatex">\(\gamma_1, \dots , \gamma_{\ell}\)</span> are 
forward <span class="arithmatex">\(\alpha\)</span>-arrows with </p>
<div class="arithmatex">\[
\beta_k \circ \cdots \circ \beta_1,
\gamma_{\ell} \circ \cdots \circ \gamma_1: w \to w^{(n)}
\]</div>
<p>in <span class="arithmatex">\(\wp\)</span>, then <span class="arithmatex">\((\beta_k)_A  \circ \cdots \circ (\beta_1)_A
= (\gamma_{\ell})_A \circ \cdots \circ (\gamma_1)_A\)</span> in <span class="arithmatex">\(\mm\)</span>.
\end{customprop}</p>
<p><span style="display:block" class="proof">
To prove the desired statement, we proceed by induction 
on the rank of a pure binary word <span class="arithmatex">\(w\)</span>. 
In what follows we write we will write <span class="arithmatex">\(w = u \otimes v\)</span> since <span class="arithmatex">\(\ll(w) \ge 3\)</span>. </p>
<p>For our base case let <span class="arithmatex">\(w\)</span> be a word of rank 0. Then by Proposition \ref{proposition:rank_is_zero} 
we see that <span class="arithmatex">\(w = w^{(n)}\)</span> so that this statement is trivial. </p>
<p>Next suppose the statement is true for all words with rank at 
most <span class="arithmatex">\(k\)</span> where <span class="arithmatex">\(k \ge 0\)</span>. Let <span class="arithmatex">\(w\)</span> be a pure binary word of rank <span class="arithmatex">\(k+1\)</span>.
We want to show that the diagram in <span class="arithmatex">\(\mm\)</span></p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_12.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
is commutative. By the Diamond Lemma \ref{lemma:diamond_lemma}, 
there exists exist a pure binary word <span class="arithmatex">\(z\)</span> and two composites of 
forward <span class="arithmatex">\(\alpha\)</span>-arrows <span class="arithmatex">\(\beta'\)</span> and <span class="arithmatex">\(\gamma'\)</span> such that the diagram below 
is commutative in <span class="arithmatex">\(\mm\)</span>. </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_13.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
Let <span class="arithmatex">\(\Gamma_z: z \to w^{(n)}\)</span> by any composition of forward <span class="arithmatex">\(\alpha\)</span>-arrows from <span class="arithmatex">\(z\)</span> to <span class="arithmatex">\(w^{(n)}\)</span>; 
at least one must exist by Proposition \ref{proposition_existence_of_w_to_wn}. 
We can now combine our two diagrams in <span class="arithmatex">\(\mm\)</span> to obtain the diagram below. </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_14.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
By Lemma \ref{lemma:directed_decreases_rank}, we know  that forward <span class="arithmatex">\(\alpha\)</span>-arrows 
decrease rank, so that <span class="arithmatex">\(r(u_1) &lt; r(w)\)</span> and 
<span class="arithmatex">\(r(v_1) &gt; r(w)\)</span>. Hence we invoke our induction hypothesis to conclude that 
both the lower left and lower right triangles commute in <span class="arithmatex">\(\mm\)</span>. As the original upper diamond 
already commutes via the Diamond Lemma, we see that the entire diagram is commutative. 
Therefore we have that </p>
<div class="arithmatex">\[
(\beta_k)_A  \circ \cdots \circ (\beta_1)_A
= (\gamma_{\ell})_A \circ \cdots \circ (\gamma_{1})_A
\]</div>
<p>in <span class="arithmatex">\(\mm\)</span>. This completes our induction and hence the proof.
</span></p>
<p>As promised, we use the above proposition to prove 
Proposition \ref{proposition:parallel_in_M_are_equal}.</p>
<p>\begin{customprop}{\ref{proposition:parallel_in_M_are_equal}}
Let <span class="arithmatex">\((\mathcal{M}, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category, 
and let <span class="arithmatex">\(A\)</span> be an object of <span class="arithmatex">\(\mm\)</span>. Let <span class="arithmatex">\(v,w\)</span> be binary words of the same length.
If <span class="arithmatex">\(\beta_1, \dots , \beta_k\)</span> and <span class="arithmatex">\(\gamma_1, \dots , \gamma_{\ell}\)</span> are 
<span class="arithmatex">\(\alpha\)</span>-arrows with </p>
<div class="arithmatex">\[
\beta_k \circ \cdots \circ \beta_1,
\gamma_{\ell} \circ \cdots \circ \gamma_1: v \to w
\]</div>
<p>then <span class="arithmatex">\((\beta_k)_A  \circ \cdots \circ (\beta_1)_A
= (\gamma_{\ell})_A \circ \cdots \circ (\gamma_1)_A\)</span> in <span class="arithmatex">\(\mm\)</span>.
\end{customprop}</p>
<p><span style="display:block" class="proof">
We begin by denoting the domain and codomain of the <span class="arithmatex">\(\alpha\)</span>-arrows
to make our discussion clear.
Let <span class="arithmatex">\(u_0, \dots, u_k, t_0, \dots, t_{\ell}\)</span> be the pure binary words 
such that <span class="arithmatex">\(u_0 = t_0 = v\)</span>, <span class="arithmatex">\(v_k = u_{\ell} = w\)</span> and</p>
<div class="arithmatex">\[\begin{align*}
&amp;\beta_i: u_{i-1} \to  u_i, \quad i = 1, 2, \dots, k\\
&amp;\gamma_j: t_{j-1} \to  t_j, \quad j = 1, 2, \dots, \ell
\end{align*}\]</div>
<p>Note that each morphism may either be 
forward or backward. 
With this notation we can picture our parallel <span class="arithmatex">\(\alpha\)</span>-arrows in <span class="arithmatex">\(\wp\)</span> 
as below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_15.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
Now consider the image of this diagram in <span class="arithmatex">\(\mm\)</span>, 
which we do not yet know to be commutative. </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_16.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
Our goal is to show that this diagram in <span class="arithmatex">\(\mm\)</span> is in fact commutative. 
This will then show our desired equality.</p>
<p>By Proposition \ref{proposition_existence_of_w_to_wn}, we can 
connect each pure binary word <span class="arithmatex">\(u_i\)</span> and <span class="arithmatex">\(t_i\)</span>
to the terminal word <span class="arithmatex">\(w^{(n)}\)</span> with forward <span class="arithmatex">\(\alpha\)</span>-arrows
<span class="arithmatex">\(\Gamma_{u_i}: u_i \to w^{(n)}\)</span> and <span class="arithmatex">\(\Gamma_{t_i}: t_i \to w^{(n)}\)</span>.
If we add these to our diagram (and suppress the notation on the <span class="arithmatex">\(\Gamma\)</span>'s), 
it becomes</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_17.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
whose image under the proxy map in <span class="arithmatex">\(\mm\)</span> is</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_18.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
Thus the diagram has become a cone, with apex <span class="arithmatex">\(w^{(n)}\)</span>, which 
is sliced by the triangles. The base of this cone is
the original diagram. We now show that each triangle is commutative.</p>
<p>Note that each triangle is of two possible forms: it either 
consists of <span class="arithmatex">\(\beta_i\)</span> or <span class="arithmatex">\(\gamma_i\)</span>. Without loss of generality, 
consider a triangle with an instance of <span class="arithmatex">\(\beta_i\)</span>, as below. </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_19.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
Now if <span class="arithmatex">\(\beta_i\)</span> is a forward <span class="arithmatex">\(\alpha\)</span>-arrow, 
observe that by Proposition \ref{proposition:parallel_w_to_wn_equal_in_M} 
it is a commutative diagram in <span class="arithmatex">\(\mm\)</span>. </p>
<p>On the other hand, suppose <span class="arithmatex">\(\beta_i\)</span> is a backward <span class="arithmatex">\(\alpha\)</span>-arrow. 
Then <span class="arithmatex">\(\beta_i^{-1}\)</span> is a forward <span class="arithmatex">\(\alpha\)</span>-arrow.
Then we may rewrite the triangle as </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_20.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
so that it now consists entirely of forward <span class="arithmatex">\(\alpha\)</span>-arrows. This then 
allows us to apply Proposition \ref{proposition:parallel_w_to_wn_equal_in_M}<br />
to guarantee that it is a commutative diagram in <span class="arithmatex">\(\mm\)</span>. 
Thus, what we have shown is that  each triangle in the 
above diagram is commutative in <span class="arithmatex">\(\mm\)</span>. This literally means that 
for each <span class="arithmatex">\(i\)</span>, </p>
<div class="arithmatex">\[\begin{align*}
(\Gamma_{u_i})_A\circ (\beta_i)_A = (\Gamma_{u_{i-1}})_A
&amp;\implies 
(\beta_i)_A = \textcolor{NavyBlue}{(\Gamma_{u_i})_A^{-1} \circ (\Gamma_{u_{i-1}})_A} 
\\
(\Gamma_{t_i})_A\circ (\gamma_i)_A = (\Gamma_{t_{i-1}})_A
&amp;\implies 
(\gamma_i)_A = \textcolor{Purple}{(\Gamma_{t_i})_A^{-1} \circ (\Gamma_{t_{i-1}})_A}
\end{align*}\]</div>
<p>Therefore, we see that <span class="arithmatex">\((\beta_k)_A \circ \cdots \circ (\beta_1)_A\)</span>
can be written as </p>
<div class="arithmatex">\[\begin{align*}
\Big(\textcolor{NavyBlue}{(\Gamma_{u_k})_A^{-1} \circ (\Gamma_{u_{k-1}})_A}\/)
\circ
\Big( \textcolor{NavyBlue}{(\Gamma_{u_{k-1}})_A^{-1} \circ (\Gamma_{u_{k-2}})_A}\Big)
\circ \cdots \circ 
\Big(\textcolor{NavyBlue}{(\Gamma_{u_1})_A^{-1} \circ (\Gamma_{u_{0}})_A} \Big)
\end{align*}\]</div>
<p>which is a "telescoping" composition that reduces to </p>
<div class="arithmatex">\[\begin{align*}
(\Gamma_{u_k})_A^{-1} \circ (\Gamma_{u_{0}})_A.
\end{align*}\]</div>
<p>Similarly, we can expression <span class="arithmatex">\((\gamma_{\ell})_A \circ \cdots \circ (\gamma_1)_A\)</span>
as  </p>
<div class="arithmatex">\[\begin{align*}
\Big(\textcolor{Purple}{(\Gamma_{t_{\ell}})_A^{-1} \circ (\Gamma_{t_{\ell-1}})_A}\Big)
\circ 
\Big(\textcolor{Purple}{(\Gamma_{t_{\ell-1}})_A^{-1} \circ (\Gamma_{t_{\ell-2}})_A}\Big)
\circ \cdots \circ 
\Big(\textcolor{Purple}{(\Gamma_{t_1})_A^{-1} \circ (\Gamma_{t_{0}})_A} \Big)
\end{align*}\]</div>
<p>which also reduces to </p>
<div class="arithmatex">\[
(\Gamma_{t_{\ell}})_A^{-1} \circ (\Gamma_{t_{0}})_A.
\]</div>
<p>However, <span class="arithmatex">\(u_k = t_{\ell}\)</span> and <span class="arithmatex">\(u_0 = t_0\)</span>, so that </p>
<div class="arithmatex">\[
(\Gamma_{u_k})_A^{-1} \circ (\Gamma_{u_{0}})_A
=
(\Gamma_{t_{\ell}})_A^{-1} \circ (\Gamma_{t_{0}})_A
\implies
(\beta_k)_A \circ \cdots \circ (\beta_1)_A
=
(\beta_k)_A \circ \cdots \circ (\beta_1)_A
\]</div>
<p>Thus we have that our original diagram in <span class="arithmatex">\(\mm\)</span></p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_21.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
is commutative. Therefore we have that 
parallel sequences of <span class="arithmatex">\(\alpha\)</span>-arrows are equal in <span class="arithmatex">\(\mm\)</span>, as desired.
</span></p>
<p>Finally, we use all of our previous work to prove Theorem \ref{theorem:coherence_in_alpha}.
In this case, the proof is simply the definition of our desired functor.
We state the theorem here for the reader's convenience.</p>
<div class="arithmatex">\[\begin{customthm}{\ref{theorem:coherence_in_alpha}}[Associator Coherence.]
Let $(\mm, \otimes, I, \alpha, \lambda, \rho)$ be a monoidal category. 
For every object $A$, there exists a unique functor 
$\Phi_A: \ww_P \to \mm$ which agrees with the proxy map $(-)_A$ on the objects and $\alpha$-arrows.
\end{customthm}\]</div>
<p>To define this functor, we will (in this order) define the functor on 
(1) object, (2) <span class="arithmatex">\(\alpha\)</span>-arrows, (3) general morphisms of <span class="arithmatex">\(\wp\)</span>, and then 
finally show that our definition preserves composition.</p>
<ul>
<li><strong>Objects.</strong> For a pure binary word <span class="arithmatex">\(w\)</span>, we define <span class="arithmatex">\(\Phi_A(w) = (w)_A\)</span>.</li>
<li>
<p><strong>Morphisms.</strong></p>
<ul>
<li><strong>(1)</strong> If <span class="arithmatex">\(\beta\)</span> is an <span class="arithmatex">\(\alpha\)</span>-arrow, we define 
<span class="arithmatex">\(\Phi_A(\beta) = (\beta)_A\)</span>.</li>
<li><strong>(2)</strong> Now we define our functor on a general morphism <span class="arithmatex">\(v \to w\)</span> in <span class="arithmatex">\(\wp\)</span>. For convenience 
denote this as <span class="arithmatex">\(\phi_{v,w}: v \to w\)</span>. </li>
</ul>
<p>We know by 
Corollary \ref{corollary:morphisms_of_wp} that there exist finitely many 
forward and backward <span class="arithmatex">\(\alpha\)</span>-arrows <span class="arithmatex">\(\gamma_1, \dots, \gamma_k\)</span> such  that </p>
<div class="arithmatex">\[
\phi_{v,w} = \gamma_k \circ \cdots \circ \gamma_1. 
\]</div>
<p>Therefore, define </p>
<div class="arithmatex">\[
\Phi_A(\phi_{v,w}) = \Phi(\gamma_k \circ \cdots \circ \gamma_1)= (\gamma_k)_A \circ \cdots \circ (\gamma_1)_A.
\]</div>
<p>By Proposition \ref{proposition:parallel_in_M_are_equal}, we see that 
this definition is well-defined.</p>
</li>
</ul>
<p>We conclude this section by proving the Diamond Lemma, which we have now 
seen to play a critical role in this proof. 
\begin{customlemma}{\ref{lemma:diamond_lemma}}[Diamond Lemma]
Let <span class="arithmatex">\(w\)</span> be a pure binary word and suppose <span class="arithmatex">\(\beta_1,\beta_2\)</span> are two 
forward <span class="arithmatex">\(\alpha\)</span>-arrows as below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_22.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
There exists a pure binary word <span class="arithmatex">\(z\)</span> and two <span class="arithmatex">\(\gamma_1: w_1 \to z, \gamma_2: w_2 \to z\)</span>,
with <span class="arithmatex">\(\gamma_1, \gamma_2\)</span> a composition of forward <span class="arithmatex">\(\alpha\)</span>-arrows,
such that for any monoidal category 
<span class="arithmatex">\((\mm, \otimes, I, \alpha, \lambda, \rho)\)</span> the diagram below is 
commutative in <span class="arithmatex">\(\mm\)</span>.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_23.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
is commutative. 
\end{customlemma}</p>
<p>As we said before, the above lemma is an existence result, 
so we emphasize this fact by coloring 
the arrows, which we are asserting to exist, Green. </p>
<p><span style="display:block" class="proof">
We will prove this using induction on the length of <span class="arithmatex">\(w = u \otimes v\)</span>.
Therefore, throughout the proof, suppose the result is already true for all words of length less than that 
of <span class="arithmatex">\(w\)</span>. </p>
<p>We proceed in a case-by-case basis, exhausting the possible forms of <span class="arithmatex">\(\beta_1\)</span> and <span class="arithmatex">\(\beta_2\)</span>.
For our purposes, we will express <span class="arithmatex">\(w = u \otimes v\)</span>. 
Whenever <span class="arithmatex">\(\ll(v) &gt; 1\)</span>, we write <span class="arithmatex">\(v= s \otimes t\)</span>. </p>
<p>Let <span class="arithmatex">\(\beta_1, \beta_2\)</span> be forward <span class="arithmatex">\(\alpha\)</span>-arrows. 
Then <span class="arithmatex">\(\beta_1\)</span> could be of the forms</p>
<div class="arithmatex">\[
\alpha_{u,s,t}\qquad 1_u \otimes \gamma_1 \qquad \gamma_1\otimes 1_v
\]</div>
<p>and <span class="arithmatex">\(\beta_2\)</span> could be of the forms </p>
<div class="arithmatex">\[
\alpha_{u,s,t}\qquad 1_u\otimes\gamma_2 \qquad \gamma_2\otimes 1_v.
\]</div>
<p>with <span class="arithmatex">\(\gamma_1, \gamma_2\)</span> already forward <span class="arithmatex">\(\alpha\)</span>-arrows.
Therefore, our cases for <span class="arithmatex">\(\beta_1,\beta_2\)</span>, 
displayed in tuples, are listed in the table below.
\begin{center}</p>
<table>
<thead>
<tr>
<th><span class="arithmatex">\((\beta_1,\beta_2)\)</span></th>
<th><span class="arithmatex">\(\alpha_{u,s,t}\)</span></th>
<th><span class="arithmatex">\(1_u\otimes \gamma_2\)</span></th>
<th><span class="arithmatex">\(\gamma_2 \otimes 1_v\)</span> \ [0.2cm]  <span class="arithmatex">\(\alpha_{u,s,t}\)</span></th>
<th><span class="arithmatex">\(\textcolor{Red}{(\alpha_{u,s,t}, \alpha_{u,s,t})}\)</span></th>
<th><span class="arithmatex">\(\textcolor{NavyBlue}{(\alpha_{u,s,t},1_u \otimes \gamma_2)}\)</span></th>
<th><span class="arithmatex">\(\textcolor{Orange}{(\alpha_{u,s,t}, \gamma_2\otimes 1_v)}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>0.2cm] <span class="arithmatex">\(1_u \otimes \gamma_1\)</span></td>
<td><span class="arithmatex">\(\textcolor{NavyBlue}{(1_u \otimes \gamma_1, \alpha_{u,s,t})}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Magenta}{(1_u \otimes \gamma_1 ,1_u \otimes \gamma_2)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Purple}{(1_u \otimes \gamma_1, \gamma_2\otimes 1_v)}\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0.2cm] <span class="arithmatex">\(\gamma_1\otimes 1_v\)</span></td>
<td><span class="arithmatex">\(\textcolor{Orange}{(\gamma_1\otimes 1_v, \alpha_{u,s,t})}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Purple}{(\gamma_1\otimes 1_v ,1_u \otimes \gamma_2)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{ProcessBlue}{(\gamma_1\otimes 1_v, \gamma_2\otimes 1_v)}\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>\end{center} <br />
While there are 9 cases displayed above, we have pointed out via color the pairs of cases which are logically 
equivalent to each other due to the symmetry of our problem. Therefore, we actually have 6 cases to check 
We now proceed to the proof.</p>
<p>\noindent<strong>Case 1:</strong> <span class="arithmatex">\(\textcolor{Red}{(\alpha_{u,s,t}, \alpha_{u,s,t})}.\)</span>\
In this case, we have that <span class="arithmatex">\(\beta_1 =  \beta_2\)</span>, for which the statement is trivially true.
\</p>
<p>\noindent<strong>Case 2:</strong> <span class="arithmatex">\(\textcolor{Purple}{(\gamma_1\otimes 1_v ,1_u \otimes \gamma_2)}\)</span>\
Suppose <span class="arithmatex">\(\beta_1 = \gamma_1 \otimes 1_v\)</span> and <span class="arithmatex">\(\beta_2 = 1_u\otimes \gamma_2\)</span>. 
Here, <span class="arithmatex">\(\gamma_1: u \to u'\)</span> and <span class="arithmatex">\(\gamma_2: v \to  v'\)</span> for some pure binary 
words $ u',v'$. Then we get the diagram </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_24.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which commutes by the bifunctoriality of <span class="arithmatex">\(\otimes\)</span>. 
\
\
<strong>Case 3:</strong> <span class="arithmatex">\(\textcolor{ProcessBlue}{(\gamma_1\otimes 1_v, \gamma_2\otimes 1_v)}\)</span>\
Suppose <span class="arithmatex">\(\beta_1 = \gamma_1 \otimes 1_v\)</span> and <span class="arithmatex">\(\beta_2 = \gamma_2 \otimes 1_v\)</span>
with <span class="arithmatex">\(\gamma_1: u \to u_1\)</span> and <span class="arithmatex">\(\gamma_2: u \to u_2\)</span> both forward <span class="arithmatex">\(\alpha\)</span>-arrows.</p>
<p>Then in this case we have the triangle below in <span class="arithmatex">\(\mm\)</span>.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_25.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
Note that the above diagram 
is the image of diagram </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_26.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
under the functor <span class="arithmatex">\((-)\otimes (v)_A\)</span>. As <span class="arithmatex">\(\ll(u) &lt; \ll(u\otimes v)\)</span>, 
we know by our induction hypothesis that 
there exists a pure binary word <span class="arithmatex">\(z\)</span>
and a pair of composite, forward <span class="arithmatex">\(\alpha\)</span>-arrows <span class="arithmatex">\(\sigma_1: u_1 \to z\)</span> and 
<span class="arithmatex">\(\sigma_2: u_2 \to z\)</span> such that the diagram below commutes in <span class="arithmatex">\(\mm\)</span>.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_27.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
Therefore we can apply the functor 
<span class="arithmatex">\((-)\otimes (v)_A\)</span> on the above diagram 
to obtain the commutative diagram below</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_28.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which proves this case.
\
\
<strong>Case 4:</strong> <span class="arithmatex">\(\textcolor{Magenta}{(1_u \otimes \gamma_1 ,1_u \otimes \gamma_2)}\)</span>\
The next case is when <span class="arithmatex">\(\beta_1 = 1_u \otimes \gamma_1\)</span> and <span class="arithmatex">\(\beta_2 = 1_u\otimes\gamma_2\)</span><br />
with <span class="arithmatex">\(\gamma_1: v \to v_1\)</span> and <span class="arithmatex">\(\gamma_2: v \to v_2\)</span>. However, this can be proved 
in a similar manner as the previous case using 
the induction hypothesis and the functor <span class="arithmatex">\((u)_A \otimes (-)\)</span>.
\
\noindent<strong>Case 5:</strong> <span class="arithmatex">\(\textcolor{Orange}{(\alpha_{u,s,t}, \gamma_2\otimes 1_v)}\)</span>\
Let <span class="arithmatex">\(\beta_1 = \alpha_{u,s,t}\)</span>,  so that <span class="arithmatex">\(w = u \otimes (s \otimes t)\)</span>. 
Let <span class="arithmatex">\(\beta_2 = \gamma_2 \otimes 1_{v}
= \gamma_2 \otimes 1_{s\otimes t}\)</span> 
with <span class="arithmatex">\(\gamma_2: u \to u'\)</span>
a forward <span class="arithmatex">\(\alpha\)</span>-arrow. Then we will have the diagram in <span class="arithmatex">\(\mm\)</span></p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_29.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which commutes in <span class="arithmatex">\(\mm\)</span> by naturality of <span class="arithmatex">\(\alpha\)</span>. 
\
\
<strong>Case 6:</strong> <span class="arithmatex">\(\textcolor{NavyBlue}{(\alpha_{u,s,t},1_u \otimes \gamma_2)}\)</span>\
Let <span class="arithmatex">\(\beta_1 = \alpha_{u,s,t}\)</span>, <span class="arithmatex">\(\beta_2 = 1_u \otimes \gamma\)</span>
with <span class="arithmatex">\(\gamma\)</span> a forward <span class="arithmatex">\(\alpha\)</span>-arrow with domain <span class="arithmatex">\(s \otimes t\)</span>. 
By the recursive definition of a forward <span class="arithmatex">\(\alpha\)</span>-arrow, 
we have three possible cases for <span class="arithmatex">\(\gamma\)</span>.
\
\
<strong>Case 6.1: </strong><span class="arithmatex">\(\gamma = 1_s \otimes \gamma'\)</span>\
With <span class="arithmatex">\(\gamma = 1_s \otimes \gamma'\)</span> with <span class="arithmatex">\(\gamma' : t\to t'\)</span> 
already a forward <span class="arithmatex">\(\alpha\)</span>-arrow,
we have the diagram in <span class="arithmatex">\(\mm\)</span></p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_30.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which commutes in <span class="arithmatex">\(\mm\)</span> by naturality of <span class="arithmatex">\(\alpha\)</span>.
\
\
<strong>Case 6.2:</strong> <span class="arithmatex">\(\gamma = \gamma' \otimes 1_t\)</span>\
If <span class="arithmatex">\(\gamma = \gamma' \otimes 1_t\)</span> with <span class="arithmatex">\(\gamma': s \to s'\)</span> 
already a forward <span class="arithmatex">\(\alpha\)</span>-arrow, we can create the diagram </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_31.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which also commutes in <span class="arithmatex">\(\mm\)</span> by naturality of <span class="arithmatex">\(\alpha\)</span>.
\
<strong>Case 6.3:</strong> <span class="arithmatex">\(\gamma = \alpha_{s,p,q}\)</span>\
The third case for <span class="arithmatex">\(\gamma\)</span> is when <span class="arithmatex">\(\gamma = \alpha_{s,p,q}\)</span>. 
In this case, we 
express <span class="arithmatex">\(w = u\otimes (s\otimes (p \otimes q))\)</span>. 
We can then construct the diagram  </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_32.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which is always commutative in <span class="arithmatex">\(\mm\)</span>.
In this case, the word <span class="arithmatex">\(((u\otimes s)\otimes p)\otimes q\)</span>
acts as our vertex <span class="arithmatex">\(z\)</span> which completes the diagram. </p>
<p>As we have exhausted all possible cases,
we see that the statement is true for pure binary words of rank <span class="arithmatex">\(k+1\)</span>
if it is true for all pure binary words with rank at most <span class="arithmatex">\(k\)</span>.
By induction, the statement is true for all binary words of any rank, 
so that we have proved the theorem.
</span></p>
<p>\subsection*{Step Four: Binary Words}</p>
<p>So far we have established a unique functor <span class="arithmatex">\(\Phi_A: \wp \to \mm\)</span> 
for each object <span class="arithmatex">\(A\)</span> of any given monoidal category <span class="arithmatex">\(\mm\)</span>,
and this functor grants us coherence in the associators between iterated 
monoidal products of a single object.
We now consider such monoidal products with the identity <span class="arithmatex">\(I\)</span> as well, 
so that we may say something about coherence with regard to the 
unitors <span class="arithmatex">\(\lambda\)</span> and <span class="arithmatex">\(\rho\)</span> in a general monoidal category. 
Towards that goal, we now consider binary words (not just pure binary words)
and introduce some definitions.</p>
<p>Recall that <span class="arithmatex">\(\ll\)</span> calculates the length of a binary word, or more informally, 
the number of <span class="arithmatex">\(x_1\)</span>'s in a binary word. We now introduce a dual quantity which 
instead counts the number of <span class="arithmatex">\(x_0\)</span></p>
<p><span style="display:block" class="definition">
Let <span class="arithmatex">\(w\)</span> be a binary word. Define the <strong>identity length</strong> of <span class="arithmatex">\(w\)</span>, 
denoted <span class="arithmatex">\(\mathcal{E}\)</span>, recursively as follows. </p>
<ul>
<li><span class="arithmatex">\(\ee(x_0) = 1\)</span> and <span class="arithmatex">\(\ee(x_1) = 0\)</span>.</li>
<li><span class="arithmatex">\(\ee(u \otimes v) = \ee(u) + \ee(v)\)</span>.</li>
</ul>
<p></span></p>
<p>Similarly to how <span class="arithmatex">\(\ll(-)\)</span> counts the number of <span class="arithmatex">\(x_1\)</span>'s in a binary word, <span class="arithmatex">\(\ee(-)\)</span> 
counts the number of <span class="arithmatex">\(x_0\)</span>'s in a binary word.</p>
<p>Next, we introduce the following concept that will later on 
be key to our proof of Mac Lane's Coherence Theorem.</p>
<p><span style="display:block" class="definition">
Let <span class="arithmatex">\(w\)</span> be a binary word. 
We define the <strong>clean word</strong> derived from <span class="arithmatex">\(w\)</span>,
denoted <span class="arithmatex">\(\overline{w}\)</span>, recursively as follows. </p>
<ul>
<li>We set <span class="arithmatex">\(\overline{x_1} = x_1\)</span>.</li>
<li>If <span class="arithmatex">\(\ll(w) = 0\)</span> (i.e., it has no instance of <span class="arithmatex">\(x_1\)</span>) then <span class="arithmatex">\(\overline{w} = x_0\)</span>.</li>
<li>Let <span class="arithmatex">\(u,v\)</span> be binary words with <span class="arithmatex">\(\ll(u) = 0\)</span> and <span class="arithmatex">\(\ll(v) &gt; 0\)</span>. 
Then
[
\overline{u \otimes v} = \overline{v \otimes u} = \overline{v}
]</li>
<li>Let <span class="arithmatex">\(u,v\)</span> be binary words with <span class="arithmatex">\(\ll(u), \ll(v) &gt; 0\)</span>. Then 
<span class="arithmatex">\(\overline{u\otimes v} =  \overline{u} \otimes \overline{v}\)</span>.</li>
</ul>
<p></span></p>
<p>Note that for a pure binary word <span class="arithmatex">\(w\)</span>, we have that <span class="arithmatex">\(\overline{w} =w\)</span>.
Informally, the clean word of a binary word of nonzero length is simply the pure 
binary word obtained by removing all instances of the identity from its 
expression. In the case for a binary word with zero length, we naturally define 
the clean word to be <span class="arithmatex">\(x_0\)</span> .</p>
<p><span style="display:block" class="example">
We offer some examples of clean words obtained from binary words.
\begin{center}</p>
<table>
<thead>
<tr>
<th>Word</th>
<th>Clean Word</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(x_0\otimes (x_0 \otimes x_0)\)</span></td>
<td><span class="arithmatex">\(x_0\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(x_0 \otimes (x_1 \otimes x_0)\)</span></td>
<td><span class="arithmatex">\(x_1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\((x_1 \otimes x_0) \otimes x_1\)</span></td>
<td><span class="arithmatex">\(x_1 \otimes x_1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(((x_1 \otimes x_0) \otimes x_0)\otimes x_1\)</span></td>
<td><span class="arithmatex">\(x_1 \otimes x_1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\((x_1 \otimes x_0) \otimes ((x_1 \otimes x_0) \otimes x_1)\)</span></td>
<td><span class="arithmatex">\(x_1 \otimes (x_1 \otimes x_1)\)</span></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>\end{center}The above example also shows that two different binary words 
can have the same clean word. 
</span></p>
<p><span style="display:block" class="definition">[Monoidal Arrows]
A <strong>forward monoidal</strong> arrow of <span class="arithmatex">\(\ww\)</span> is defined recursively as follows. </p>
<ul>
<li>For any triple of binary words <span class="arithmatex">\(u, v, w\)</span>, the morphisms </li>
</ul>
<div class="arithmatex">\[\begin{align*}
\alpha_{u, v, w}&amp;: u \otimes (v \otimes w) \isomarrow (u \otimes v)\otimes w\\
\lambda_{u}&amp;: x_0 \otimes u \isomarrow u\\
\rho_{u}&amp;: u\otimes x_0 \isomarrow u
\end{align*}\]</div>
<p>are, respectively, <strong>forward</strong> <span class="arithmatex">\(\alpha\)</span>-, <span class="arithmatex">\(\lambda\)</span>-, and <span class="arithmatex">\(\rho\)</span>-<strong>arrows</strong>. 
They are collectively 
defined to be <strong>forward monoidal arrows</strong>.
* For any binary word <span class="arithmatex">\(u\)</span> and forward monoidal arrow <span class="arithmatex">\(\mu\)</span>, the morphisms</p>
<div class="arithmatex">\[
1_{u} \otimes \mu \qquad \mu \otimes 1_{u}
\]</div>
<p>are forward monoidal arrows.</p>
<p>Finally, we say a <strong>backward monoidal arrow</strong> 
is the inverse of a forward monoidal arrow. 
</span></p>
<p>We also establish the following terminology to distinguish our <span class="arithmatex">\(\alpha\)</span>-arrows 
from our <span class="arithmatex">\(\lambda\)</span> and <span class="arithmatex">\(\rho\)</span> arrows.</p>
<p><span style="display:block" class="definition">
A <strong>forward unitor arrow</strong> is either a forward <span class="arithmatex">\(\lambda\)</span>-arrow or a forward <span class="arithmatex">\(\rho\)</span>-arrow.
Similarly, a  <strong>backward unitor arrow</strong> is the inverse of a forward unitor arrow.
</span></p>
<p>As we have already seen forward <span class="arithmatex">\(\alpha\)</span>-arrows, 
we provide examples of forward and backward <span class="arithmatex">\(\lambda, \rho\)</span>-arrows.</p>
<p><span style="display:block" class="example">
Below we have a forward and backward <span class="arithmatex">\(\lambda\)</span>-arrow.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_33.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
We also have forward and backward <span class="arithmatex">\(\rho\)</span>-arrows below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_34.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
</span></p>
<p>We now move onto proving some important lemmas regarding 
monoidal arrows that we will use for the coherence theorem.</p>
<p>The first three are quick, but have particular importance. </p>
<p><span style="display:block" class="lemma">
Let <span class="arithmatex">\(w\)</span> be a binary word, <span class="arithmatex">\(w \ne x_0\)</span>. 
Then <span class="arithmatex">\(\ee(w) = 0\)</span> if and only if <span class="arithmatex">\(w = \overline{w}\)</span>. 
</span></p>
<p>Note that <span class="arithmatex">\(w = x_0\)</span> is the only case for which the above proposition is not true, 
since <span class="arithmatex">\(x_0 = \overline{x_0}\)</span> but <span class="arithmatex">\(\ee(x_0) \ne 0\)</span>. Hence,
our reasoning for excluding it (and it is not a case we will need to concern ourselves with).</p>
<p><span style="display:block" class="proof">
Suppose <span class="arithmatex">\(\ee(w) = 0\)</span>, and let us prove the forward direction by induction on 
the length of the word. 
Let us write <span class="arithmatex">\(w = u \otimes v\)</span>, suppose that the statement is true for all pure binary words with 
length less than <span class="arithmatex">\(w\)</span>. Observe that  </p>
<div class="arithmatex">\[
w = u \otimes v = \overline{u} \otimes \overline{v} = \overline{u \otimes v} = \overline{w}.
\]</div>
<p>where we used the induction hypothesis on <span class="arithmatex">\(u, v\)</span> which have smaller length than 
<span class="arithmatex">\(w\)</span>. Thus we see that <span class="arithmatex">\(w = \overline{w}\)</span>. </p>
<p>Conversely, suppose <span class="arithmatex">\(\overline{w} = w\)</span>, <span class="arithmatex">\(w \ne x_0\)</span>, and suppose the statement is true for binary words 
with length less than <span class="arithmatex">\(w\)</span>. Write <span class="arithmatex">\(w  = u \otimes v\)</span>. 
By the definition 
of a clean word, the only way we can have <span class="arithmatex">\(\overline{w} = w\)</span> is if <span class="arithmatex">\(u,v\)</span> 
are binary words with nonzero length. 
Therefore, if <span class="arithmatex">\(\overline{w} = w\)</span> we see that </p>
<div class="arithmatex">\[
\overline{u} \otimes \overline{v} = u \otimes v.
\]</div>
<p>Since <span class="arithmatex">\(u, v\)</span> have smaller length than <span class="arithmatex">\(w\)</span>, we may use the induction 
hypothesis to conclude that <span class="arithmatex">\(\ee(u) = \ee(v) = 0\)</span>. Hence, 
<span class="arithmatex">\(\ee(w) = 0\)</span>, as desired. 
</span></p>
<p><span style="display:block" class="lemma">
Let <span class="arithmatex">\(w\)</span> be a binary word. Suppose
<span class="arithmatex">\(\iota: w \to w'\)</span> is a forward unitor arrow. 
Then <span class="arithmatex">\(\ee(w') = \ee(w) - 1\)</span>. 
</span></p>
<p>In other words, any unitor arrow always takes away exactly one identity.</p>
<p><span style="display:block" class="proof">
We prove this by examining the possible cases for <span class="arithmatex">\(\iota\)</span>. 
Write <span class="arithmatex">\(w = u \otimes v\)</span>.
As <span class="arithmatex">\(\iota\)</span> is a forward unitor arrow, it has four possible forms. </p>
<ul>
<li><strong>(1)</strong> Suppose <span class="arithmatex">\(\iota = \lambda_v: x_0 \otimes v \to v\)</span>. 
As </li>
</ul>
<div class="arithmatex">\[
\ee(v) = \ee(v) + \ee(x_0) - 1 = \ee(v \otimes x_0) - 1   
\]</div>
<p>we see that the statement is satisfied in this case.
* <strong>(2)</strong> If <span class="arithmatex">\(\iota = \rho_u: u \otimes x_0 \to u\)</span>,
we can use a similar argument as in (1) to prove the statement.
* <strong>(3)</strong> Suppose <span class="arithmatex">\(\iota = 1_{u} \otimes \kappa: u \otimes v \to u \otimes v'\)</span> 
where <span class="arithmatex">\(\kappa: v \to v'\)</span> is a forward unitor arrow for which the 
statement is already true. Then <span class="arithmatex">\(\ee(v') = \ee(v) - 1\)</span>. Hence, </p>
<div class="arithmatex">\[
\ee(u \otimes v') = \ee(u \otimes v) - 1. 
\]</div>
<p>Therefore the statement is satisfied for <span class="arithmatex">\(1_u \otimes \kappa\)</span> if it is 
true for <span class="arithmatex">\(\kappa\)</span>.
* <strong>(4)</strong> If <span class="arithmatex">\(\iota = \kappa \otimes 1_v: u \otimes v \to u' \otimes v\)</span>
where <span class="arithmatex">\(\kappa\)</span> is a forward unitor for which the statement is already true, 
then we may prove this case by following a similar argument as in (3).</p>
<p>As we have examined all cases, we may conclude that for every 
forward unitor <span class="arithmatex">\(\iota: w \to w'\)</span>, we have that <span class="arithmatex">\(\ee(w') = \ee(w) - 1\)</span> 
as desired. 
</span></p>
<p><span style="display:block" class="lemma">
Let <span class="arithmatex">\(\iota: w \to w'\)</span> be a forward unitor arrow. Then 
<span class="arithmatex">\(\overline{w} = \overline{w}'\)</span>. 
</span></p>
<p>In other words, unitor arrows do not alter the particular format of a
clean word.</p>
<p><span style="display:block" class="proof">
First, observe that the result is trivial if <span class="arithmatex">\(\ll(w) = \ll(w') = 0\)</span>. 
Therefore, let <span class="arithmatex">\(w = u \otimes v\)</span> be such a binary 
word with <span class="arithmatex">\(\ee(w) &gt; 0\)</span>.
Suppose the statement is true for 
binary words <span class="arithmatex">\(v\)</span> such that <span class="arithmatex">\(\ee(v) &lt; \ee(w)\)</span>. 
Let <span class="arithmatex">\(\iota:w \to w'\)</span> be a forward unitor arrow. 
By the recursive definition of <span class="arithmatex">\(\iota\)</span>, our forward unitor arrow has 
four possible forms. </p>
<ul>
<li><strong>(1)</strong> Suppose <span class="arithmatex">\(\iota = \lambda_v: x_0 \otimes v \to v\)</span>. 
However, note that <span class="arithmatex">\(\overline{x_0 \otimes v} = \overline{v}\)</span>, 
so that this case is true.</li>
<li><strong>(2)</strong> If <span class="arithmatex">\(\iota = \rho_u: u \otimes x_0 \to u\)</span>, 
then this case may be proven in a similar manner as case (1).</li>
<li><strong>(3)</strong> Suppose 
<span class="arithmatex">\(\iota = 1_u \otimes \kappa: u \otimes v \to u \otimes v'\)</span> where 
<span class="arithmatex">\(\kappa\)</span> is a forward unitor arrow for which the result is already true. 
Since <span class="arithmatex">\(\ll(u \otimes v) &lt; 0\)</span>, we have a few subcases. </li>
</ul>
<p>Suppose <span class="arithmatex">\(\ll(v) &gt; 0\)</span>. 
Then by our assumption on <span class="arithmatex">\(\kappa\)</span>, 
<span class="arithmatex">\(\overline{v} = \overline{v}'\)</span>.
Therefore, if 
<span class="arithmatex">\(\ll(u) = 0\)</span>, we see that </p>
<div class="arithmatex">\[
\overline{u \otimes v} = \overline{v} 
= \overline{v}' = \overline{u \otimes v}'
\]</div>
<p>which satisfies this case. 
If instead <span class="arithmatex">\(\ll(u) &gt; 0\)</span>, then </p>
<div class="arithmatex">\[
\overline{u \otimes v} = \overline{u}\otimes\overline{v} = 
\overline{u}\otimes\overline{v}' = \overline{u \otimes v}'
\]</div>
<p>which again satisfies the case. </p>
<p>Finally, suppose <span class="arithmatex">\(\ll(v) = 0\)</span>. 
Then <span class="arithmatex">\(\overline{u \otimes v} = 
\overline{u} = \overline{u \otimes v}'\)</span>. </p>
<p>In all cases we see that <span class="arithmatex">\(\overline{u \otimes v} = \overline{u \otimes v}'\)</span> 
as desired.
* <strong>(3)</strong> Our third case if when <span class="arithmatex">\(\iota = \kappa \otimes 1_v: u \otimes v \to u' \otimes v\)</span> 
with <span class="arithmatex">\(\kappa\)</span> a forward  unitor for which the result is already true. However, this 
case can be proved similarly as in case (2).</p>
<p>In all instances, we see that for a forward unitor arrow <span class="arithmatex">\(\iota: w \to w'\)</span>, 
we have that <span class="arithmatex">\(\overline{w} = \overline{w}'\)</span>, as desired. 
</span></p>
<p>The following lemma is an important existence result that will be used in the 
next proposition.</p>
<p><span style="display:block" class="lemma">
Let <span class="arithmatex">\(w\)</span> be a binary word with <span class="arithmatex">\(\ee(w) &gt; 0\)</span>.
Then there exists a forward unitor with domain <span class="arithmatex">\(w\)</span>.
</span></p>
<p><span style="display:block" class="proof">
We prove this by induction on the total length of a binary word 
<span class="arithmatex">\(\ll(w) + \ee(w)\)</span>. 
Thus, let <span class="arithmatex">\(w = u \otimes v\)</span> be a binary word with <span class="arithmatex">\(\ee(w) &gt; 0\)</span> 
and suppose the statement is true 
for all binary words <span class="arithmatex">\(z\)</span> with</p>
<div class="arithmatex">\[
\ll(z) + \ee(z) &lt; \ll(w) + \ee(w).
\]</div>
<p>Then we have a few cases for <span class="arithmatex">\(w\)</span>. </p>
<ul>
<li><strong>(1)</strong> Suppose <span class="arithmatex">\(u = x_0\)</span>. Then we take the forward unitor 
<span class="arithmatex">\(\lambda_v: x_0 \otimes v \to v\)</span>.</li>
<li><strong>(2)</strong> Suppose <span class="arithmatex">\(v = x_0\)</span>. We may similarly take <span class="arithmatex">\(\rho_u: u \otimes x_0 \to u\)</span>, 
so that this case is satisfied.</li>
<li><strong>(3)</strong> Suppose <span class="arithmatex">\(u, v \ne x_0\)</span>. Since <span class="arithmatex">\(\ee(w) &gt; 1\)</span>, 
either <span class="arithmatex">\(\ee(u)\)</span> or <span class="arithmatex">\(\ee(v) &gt; 0\)</span>. Without loss of generality, suppose 
<span class="arithmatex">\(\ee(u) &gt; 0\)</span>. Since </li>
</ul>
<div class="arithmatex">\[
\ll(u) + \ee(u) = \ll(u) + \ee(u)
\]</div>
<p>we may apply our induction hypothesis to conclude that there exists 
a forward unitor <span class="arithmatex">\(\iota: u \to u'\)</span> with domain <span class="arithmatex">\(u\)</span>. 
Hence, the morphism </p>
<div class="arithmatex">\[
\iota \otimes 1_v : u \otimes v \to u' \otimes v
\]</div>
<p>is a forward unitor with domain <span class="arithmatex">\(u \otimes v = w\)</span>.</p>
<p>As we have evaluated all cases, we see that the statement is true for all
binary words as desired. 
</span></p>
<p>The previous four lemmas now give rise to the following proposition. </p>
<p><span style="display:block" class="proposition">
Let <span class="arithmatex">\(w\)</span> be a binary word with <span class="arithmatex">\(\ee(w) = \ell\)</span>. Then there exists a 
composable sequence of
<span class="arithmatex">\({\ell}\)</span>-many forward unitor arrows <span class="arithmatex">\(\iota_{\ell}, \cdots, \iota_1\)</span> as below:</p>
<div class="arithmatex">\[
\iota_{\ell} \circ \cdots \circ \iota_1: w \to w'.
\]</div>
<p>Moreover, for every such chain, we have that <span class="arithmatex">\(w' = \overline{w}\)</span>. 
</span></p>
<p><span style="display:block" class="proof">
To prove existence of such a chain for every binary word with nonzero identity 
length, we may proceed by induction.
Let <span class="arithmatex">\(w\)</span> be a binary word with <span class="arithmatex">\(\ee(w) &gt; 0\)</span>, and 
suppose that such a chain exists for binary words <span class="arithmatex">\(v\)</span> with 
<span class="arithmatex">\(\ee(v) &lt; \ee(w)\)</span>. Then by Lemma 2.5.10, there exists a forward unitor 
<span class="arithmatex">\(\iota: w \to w'\)</span>. By Lemma 2.5.8, <span class="arithmatex">\(\ee(w') = \ee(w) - 1\)</span>, so by our induction 
hypothesis, there exists a chain of forward unitor arrows </p>
<div class="arithmatex">\[
\iota_{{\ell}-1}\circ \cdots \circ \iota_1: w' \to \overline{w}'.
\]</div>
<p>Hence, <span class="arithmatex">\(\iota \circ \iota_{{\ell}-1}\circ \cdots \circ \iota_1: w \to \overline{w}\)</span>
is a forward chain of unitors with initial domain <span class="arithmatex">\(w\)</span>, which proves existence.</p>
<p>To prove that <span class="arithmatex">\(w' = \overline{w}\)</span>, 
denote the domain and codomain of our unitors 
<span class="arithmatex">\(\iota_i: w_{i-1} \to w_{i}\)</span>, so that <span class="arithmatex">\(w_0 = w\)</span>. 
By Lemma 2.5.9, for each <span class="arithmatex">\(i\)</span> we have that <span class="arithmatex">\(\overline{w_{i-1}} = \overline{w_{i}}\)</span>. 
Hence <span class="arithmatex">\(\overline{w} = \overline{w_{{\ell}}}\)</span>. 
By Lemma 2.5.8, we have that <span class="arithmatex">\(\ee(w_i) = \ee(w_{i-1}) - 1\)</span>. 
Therefore, </p>
<div class="arithmatex">\[
\ee(w_{\ell}) = \ee(w) - {\ell} = 0.  
\]</div>
<p>However, by Lemma 2.5.7, we see that this implies <span class="arithmatex">\(w_{\ell} = \overline{w_{\ell}} = \overline{w}\)</span>. 
Hence we see that </p>
<div class="arithmatex">\[
\iota_{\ell} \circ \cdots \circ \iota: w \to \overline{w}
\]</div>
<p>as desired.
</span></p>
<p>The previous proposition immediately implies the next. </p>
<p><span style="display:block" class="proposition">
Let <span class="arithmatex">\(w\)</span> be a binary word with <span class="arithmatex">\(\ll(w) &gt; 0\)</span>. Then there exists a sequence 
of forward monoidal arrows from <span class="arithmatex">\(w\)</span> to <span class="arithmatex">\(w^{(n)}\)</span>. 
</span></p>
<p><span style="display:block" class="proof">
By Lemma \ref{lemma:existence_w_to_clean_w}, we have a 
sequence of forward unitor arrows from <span class="arithmatex">\(w\)</span> to <span class="arithmatex">\(\overline{w}\)</span>.</p>
<div class="arithmatex">\[
\mu_k \circ \cdots \circ \mu_1: w \to \overline{w}
\]</div>
<p>Since <span class="arithmatex">\(\overline{w}\)</span> is a 
pure binary word, we can then use Proposition \ref{proposition_existence_of_w_to_wn}
to guarantee a sequence of forward <span class="arithmatex">\(\alpha\)</span>-arrows 
from <span class="arithmatex">\(\overline{w}\)</span> to <span class="arithmatex">\(w^{(n)}\)</span>. </p>
<div class="arithmatex">\[
\beta_{\ell} \circ \cdots \circ \beta_1: \overline{w} \to w^{(n)}  
\]</div>
<p>Composing these morphisms then gives us our desired monoidal arrow:</p>
<div class="arithmatex">\[
\beta_{\ell} \circ \cdots \circ \beta_1 \circ \mu_k \circ \cdots \circ \mu_1:
w \to w^{(n)}
\]</div>
<p>so that such a sequence of forward monoidal arrows exists.
</span></p>
<p>And the previous proposition gives us the following corollary.</p>
<p><span style="display:block" class="corollary">
Every morphism in <span class="arithmatex">\(\ww\)</span> can be expressed as a composition of 
a sequence of forward and backward monoidal arrows.
</span></p>
<p><span style="display:block" class="proof">
The proof is the same exact proof as that of Corollary \ref{corollary:morphisms_of_wp}. 
We use the previous proposition with the fact that <span class="arithmatex">\(\ww\)</span> is a thin category to conclude this. 
</span></p>
<p>\subsection*{Step Five: Coherence for <span class="arithmatex">\(A^{\otimes n}\)</span> for <span class="arithmatex">\(\rho, \lambda\)</span>}</p>
<p>In this section, we extend the work we've completed with 
the associators to now include the unitors. We will obtain a theorem 
similar to Theorem \ref{theorem:coherence_in_alpha}. To even state the 
theorem, we need to introduce a new definition. </p>
<p><span style="display:block" class="definition">
Let <span class="arithmatex">\((\mm, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category. 
For each object <span class="arithmatex">\(A\)</span> in <span class="arithmatex">\(\mm\)</span>, we define the <strong>general proxy map</strong> of <span class="arithmatex">\(A\)</span>
to be the partial functor <span class="arithmatex">\((-)_A: \ww \to \mm\)</span> defined as follows. </p>
<ul>
<li>
<p><strong>Objects</strong> We define the general proxy map on objects recursively.</p>
<ul>
<li>We set <span class="arithmatex">\((x_0)_A = I\)</span> and <span class="arithmatex">\((x_1)_A = A\)</span></li>
<li>For a binary word <span class="arithmatex">\(w = u \otimes v\)</span> we set:</li>
</ul>
<p>[
(w)_A = (u \otimes v)_A = (u)_A\otimes (v)_A
]
* <strong>Morphisms</strong> We define the partial functor only on <span class="arithmatex">\(\alpha\)</span>-, <span class="arithmatex">\(\lambda\)</span>-, and <span class="arithmatex">\(\rho\)</span>-arrows. 
This is also done recursively.
* For binary words <span class="arithmatex">\(u,v,w\)</span>, we set:</p>
<p>\begin{align<em>}
(\alpha_{u,v,w})<em>A &amp;= \alpha</em>{(u_A, v_A, w_A)} : u_A \otimes (v_A \otimes w_A) \isomarrow (u_A \otimes v_A) \otimes w_A \
(\lambda_{u})<em>A &amp;= \lambda</em>{u_A}: I \otimes u_A \isomarrow u_A \
(\rho_{u})<em>A&amp;= \rho</em>{u_A} : u_A \otimes I \isomarrow u_A
\end{align</em>}
* For a more general <span class="arithmatex">\(\alpha, \lambda\)</span>, or <span class="arithmatex">\(\rho\)</span>-arrow of 
the form <span class="arithmatex">\(1_{u}\otimes \beta\)</span> or <span class="arithmatex">\(\beta\otimes 1_{u}\)</span>
we set:</p>
<div class="arithmatex">\[\begin{align*}
&amp;(1_{u} \otimes \beta)_A = 1_{u_A} \otimes (\beta)_A\\ 
&amp;(\beta \otimes 1_{u})_A = (\beta)_A\otimes 1_{u_A}
\end{align*}\]</div>
</li>
</ul>
<p>Before concluding this definition, we note that there is some potential 
ambiguity in our definition on the unitors. This is because sometimes 
a forward unitor arrow in <span class="arithmatex">\(\ww\)</span> can be expressed in two ways. </p>
<p>The reader may check that all possible cases for ambiguity are the three cases below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_35.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
As parallel morphisms in <span class="arithmatex">\(\ww\)</span>, they are equal.
Therefore, in order for our definition to be well-defined, we need 
that the corresponding pairs of morphisms</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_36.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
to be equal in <span class="arithmatex">\(\mm\)</span>. 
One can show that these morphisms are equal in <span class="arithmatex">\(\mm\)</span>
using the unitor diagrams \ref{mon_definition_diag_2}, \ref{mon_definition_diag_3}, and \ref{mon_definition_diag_4}. 
</span>
Regarding our notation, note that we are recycling the same notation from the proxy map 
to the general proxy map. This is because the only difference between the 
two is that the general proxy map is simply an extension of the proxy map which 
is now defined on identity elements <span class="arithmatex">\(x_0\)</span> and unitors. </p>
<p>The goal of this section is to prove the following theorem, which can 
be thought of as an extension of Theorem \ref{theorem:coherence_in_alpha}.</p>
<p><span style="display:block" class="theorem">[Coherence in Unitors]
Let <span class="arithmatex">\((\mm, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category. For<br />
each object <span class="arithmatex">\(A\)</span>, there exists a unique strict monoidal functor <span class="arithmatex">\(\Delta_A: \ww \to \mm\)</span> 
which agrees with the general proxy map on objects and monoidal morphisms. 
</span></p>
<p>The above theorem is implied by Proposition \ref{proposition:full_parallel_in_M_are_equal}
(stated below), in the same way that Theorem \ref{theorem:coherence_in_alpha} followed 
from Proposition \ref{proposition:parallel_in_M_are_equal}.</p>
<p><span style="display:block" class="proposition">
Let <span class="arithmatex">\((\mm, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category, and consider 
two binary words <span class="arithmatex">\(v,w\)</span>.
Let <span class="arithmatex">\(\mu_1, \dots, \mu_k\)</span> and <span class="arithmatex">\(\eta_1, \dots,\eta_{\ell}\)</span> be monoidal arrows with:</p>
<div class="arithmatex">\[
\mu_k \circ \cdots \circ \mu_1, \; \eta_{\ell} \circ \cdots \circ \eta_1: v \to w
\]</div>
<p>Then <span class="arithmatex">\((\mu_k)_A \circ \cdots \circ (\mu_1)_A = (\eta_{\ell})_A\circ\cdots\circ (\eta_1)_A\)</span> 
in <span class="arithmatex">\(\mm\)</span>.
</span></p>
<p>The above proposition is implied by Proposition \ref{proposition:full_parallel_w_to_wn} (stated below), 
in the same way that Proposition \ref{proposition:parallel_in_M_are_equal} 
followed from Proposition \ref{proposition:parallel_w_to_wn_equal_in_M}</p>
<p><span style="display:block" class="proposition">
Let <span class="arithmatex">\((\mm, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category, and consider 
a binary word <span class="arithmatex">\(w\)</span>.
Let <span class="arithmatex">\(\mu_1, \dots, \mu_k\)</span> and <span class="arithmatex">\(\eta_1, \dots,\eta_{\ell}\)</span> be forward monoidal arrows with:</p>
<div class="arithmatex">\[
\mu_k \circ \cdots \circ \mu_1,\;  \eta_{\ell} \circ \cdots \circ \eta_1: w \to w^{(n)}
\]</div>
<p>Then <span class="arithmatex">\((\mu_k)_A \circ \cdots \circ (\mu_1)_A = (\eta_{\ell})_A\circ\cdots\circ (\eta_1)_A\)</span> 
in <span class="arithmatex">\(\mm\)</span>.
</span></p>
<p>Once we have the above proposition, we can prove Proposition \ref{proposition:full_parallel_in_M_are_equal},
and hence our desired theorem, using 
the same technique as in in the Proof of Proposition \ref{proposition:parallel_in_M_are_equal}. </p>
<p>We briefly recall such techniques: We consider two parallel chains of monoidal arrows. We then 
connect each object in the chain to <span class="arithmatex">\(w^{(n)}\)</span> with a chain of forward monoidal arrow (recall that 
a chain must exist for each object).
We then have a bunch of adjacent triangles with apex <span class="arithmatex">\(w^{(n)}\)</span> and 
we can conclude via the Proposition \ref{proposition:full_parallel_w_to_wn}
that each such triangle commutes. We then conclude that 
the original two parallel chains form 
a commutative diagram in <span class="arithmatex">\(\mm\)</span>. Thus, our two chains have the same composite in <span class="arithmatex">\(\mm\)</span>.
This then proves Proposition \ref{proposition:full_parallel_in_M_are_equal},
which then grants us Theorem \ref{theorem:coherence_in_unitors}. </p>
<p>As our goal has been reduced to proving Proposition \ref{proposition:full_parallel_w_to_wn},
we prove this proposition using the following two results. </p>
<p>The first result is the following proposition.</p>
<p><span style="display:block" class="proposition">[Arrow Reorganization]
Let <span class="arithmatex">\(\mu_1, \dots, \mu_k\)</span> be composable forward monoidal arrows with 
<span class="arithmatex">\(\ell\)</span>-many unitor arrows.
Then there exist composable forward unitor arrows 
<span class="arithmatex">\(\eta_1, \dots, \eta_{\ell}\)</span> and forward <span class="arithmatex">\(\alpha\)</span>-arrows <span class="arithmatex">\(\eta_{\ell + 1}, \dots \eta_m\)</span> 
such that, for any monoidal category <span class="arithmatex">\(\mm\)</span> with object <span class="arithmatex">\(A\)</span>, we have that</p>
<div class="arithmatex">\[
(\mu_k)_A \circ \cdots \circ (\mu_1)_A = \overbrace{(\eta_m)_A \circ \cdots \circ (\eta_{\ell + 1})_A}^{\text{Forward } \alpha's}\circ \overbrace{(\eta_{\ell})_A\circ \cdots \circ (\eta_1)_A}^{\text{Unitors in front}}
\]</div>
<p>in <span class="arithmatex">\(\mm\)</span>. 
</span> </p>
<p>The above proposition basically states that monoidal arrows can be reorganized in a particular way 
with all of the unitors in the front.
The second result that we need in order to prove Proposition 
\ref{proposition:full_parallel_w_to_wn} is the following proposition. </p>
<p><span style="display:block" class="proposition">[Unitor-Chain Equivalence]
Let <span class="arithmatex">\(w\)</span> be a binary word with nonzero length and with <span class="arithmatex">\(\ee(w) = k\)</span>. 
Suppose <span class="arithmatex">\(\mu_1, \dots, \mu_k\)</span> and <span class="arithmatex">\(\eta_1, \dots, \eta_k\)</span> are a 
composable sequence of forward 
unitor arrows:</p>
<div class="arithmatex">\[
\mu_k \circ \cdots \circ \mu_1, \; \eta_k \circ \cdots \circ \eta_1: w \to \overline{w}
\]</div>
<p>Then <span class="arithmatex">\((\mu_k)_A \circ \cdots \circ (\mu_1)_A =  (\eta_k)_A \circ \cdots \circ (\eta_1)_A\)</span>
in <span class="arithmatex">\(\mm\)</span>.
</span></p>
<p>For the sake of organization, we will assume the validity of these two 
results now so that we may prove \ref{proposition:full_parallel_w_to_wn} 
We will then prove these two results in the next section.</p>
<p>\begin{varprf}[Proof of Proposition \ref{proposition:full_parallel_w_to_wn}]
\textcolor{white}{Hello!}
\
Let </p>
<div class="arithmatex">\[
\mu_{n_1} \circ \cdots \circ \mu_1, \; \eta_{n_2} \circ \cdots \circ \eta_1: w \to w^{(n)}
\]</div>
<p>be any two composites of forward monoidal arrows from <span class="arithmatex">\(w\)</span> to <span class="arithmatex">\(w^{(n)}\)</span>.
Since <span class="arithmatex">\(\ee(w) = k\)</span> and <span class="arithmatex">\(\ee( w^{(n)}) = 0\)</span>, we know 
by Lemma \ref{lemma:unitors_decrease_unit_length} that
there are exactly <span class="arithmatex">\(k\)</span>-many forward unitors in each expression. 
We can then use Proposition 
\ref{proposition:arrow_reorganization} to find forward unitor arrows<br />
<span class="arithmatex">\(\gamma_1, \dots \gamma_k, \delta_1, \dots, \delta_k\)</span> and forward <span class="arithmatex">\(\alpha\)</span>-arrows 
<span class="arithmatex">\(\gamma_{k+1}, \dots, \gamma_{m_1}\)</span>, <span class="arithmatex">\(\delta_{k+1}, \dots, \delta_{m_2}\)</span> such that:</p>
<div class="arithmatex">\[\begin{align*}
&amp;(\mu_{n_1})_A \circ \cdots \circ (\mu_1)_A = \overbrace{(\gamma_{m_1})_A \circ \cdots \circ (\gamma_{k+1})_A}^{\text{Forward } \alpha's}\circ \overbrace{(\gamma_{k})_A\circ \cdots \circ (\gamma_1)_A}^{\text{Unitors in front}}\\
&amp;(\eta_{n_2})_A \circ \cdots \circ (\eta_1)_A = \overbrace{(\delta_{m_2})_A \circ \cdots \circ (\delta_{k+1})_A}^{\text{Forward } \alpha's}\circ \overbrace{(\delta_{k})_A\circ \cdots \circ (\delta_1)_A}^{\text{Unitors in front}}
\end{align*}\]</div>
<p>By Proposition \ref{proposition:exists_w_to_clean_w}, 
we know that the domain of the composition of our unitors is <span class="arithmatex">\(\overline{w}\)</span>:</p>
<div class="arithmatex">\[
\gamma_{k} \circ \cdots \circ \gamma_1,\,
\delta_{k} \circ \cdots \circ \delta_1: w \to \overline{w}
\]</div>
<p>Diagramatically, our situation is displayed below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_37.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
By Proposition \ref{proposition:unitor_chain_equivalence}, the upper half of this diagram (above <span class="arithmatex">\((\overline{w})_A\)</span>) 
must commute. By 
Proposition \ref{proposition:parallel_in_M_are_equal}, 
the bottom half of this diagram (below <span class="arithmatex">\((\overline{w})_A\)</span>), which 
consists entirely of forward <span class="arithmatex">\(\alpha\)</span>-arrows,
must commute.
Therefore, the entire diagram commutes, and this completes the proof.
\end{varprf}</p>
<p>\subsection*{Step Six: Arrow Reorganization and Unitor Chain Equivalence}
We now discuss what it takes to prove the 
Arrow Reorganization and Unitor-Chain Equivalence results. </p>
<p>To prove the Arrow Reorganization result, it suffices to prove a special case
which is precisely stated in the following lemma.</p>
<p><span style="display:block" class="lemma">[Associator-Unitor Swap.]
Let <span class="arithmatex">\(\mu: w \to w_1\)</span> be a forward <span class="arithmatex">\(\alpha\)</span>-arrow
and let <span class="arithmatex">\(\iota: w_1 \to w_2\)</span> be a forward unitor arrow.
Then either one of the following two situations must occur.</p>
<ul>
<li>There exists a binary word <span class="arithmatex">\(z\)</span>, 
a forward unitor arrow <span class="arithmatex">\(\iota': w \to z\)</span> 
and a forward <span class="arithmatex">\(\alpha\)</span>-arrow <span class="arithmatex">\(\mu': z \to w_2\)</span> such that, for any monoidal 
category <span class="arithmatex">\(\mm\)</span>, the diagram below commutes.</li>
</ul>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_38.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
* There exists a forward unitor arrow <span class="arithmatex">\(\iota': w \to w_2\)</span> such that, for any monoidal 
category <span class="arithmatex">\(\mm\)</span>, the diagram below commutes.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_39.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/></p>
<p></span></p>
<p>As before, the above lemma is an existence result, 
so we emphasize this fact by coloring 
the arrows that we are asserting to exist Green. </p>
<p>Assuming the above lemma, we prove the Arrow Reorganization Proposition. 
\begin{varprf}[Proof of Arrow Reorganization (Proposition \ref{proposition:arrow_reorganization}).]
We summarize rather than introducing too much notation, since the proof strategy 
is rather simple.
Consider a sequence of monoidal arrows 
<span class="arithmatex">\(\mu_1, \dots, \mu_k\)</span>. Suppose <span class="arithmatex">\(\mu_{j}\)</span> is a unitor arrow. If <span class="arithmatex">\(\mu_{j-1}\)</span> 
is an <span class="arithmatex">\(\alpha\)</span>-arrow, we perform an associator-unitor swap, obtaining a new chain 
whose composite is the same in <span class="arithmatex">\(\mm\)</span>. If not, we leave it alone 
and check the other unitor arrows. </p>
<p>We perform this reorganization, swapping associator arrows and unitor arrows one at a time, 
until we have a sequence of morphisms in which no unitor arrow is preceded by 
an <span class="arithmatex">\(\alpha\)</span>-arrow (and hence all unitors begin at the front of our chain).
The repeated application of the Associator-Unitor swap guarantees that
the composite of this new chain is equal to the composite of our original chain.
\end{varprf}</p>
<p>We now understand how to prove the Arrow Reorganization Proposition: it 
relies critically on the Associator-Unitor Swap. As we now understand how the 
Associator-Unitor swap is used, we offer its proof.</p>
<p>\begin{varprf}[Proof of Associator-Unitor Swap (Lemma \ref{lemma:associator_unitor_swap}).]
We prove this using a case-by-case basis. For our proof, we write 
<span class="arithmatex">\(w = u \otimes v\)</span>. Whenever <span class="arithmatex">\(\ll(v) &gt; 1\)</span>, we write <span class="arithmatex">\(w = u\otimes (s \otimes t)\)</span>. 
If <span class="arithmatex">\(\ll(t) &gt; 1\)</span>, we will write <span class="arithmatex">\(w = u\otimes(s \otimes (p \otimes q))\)</span>. </p>
<p>Since <span class="arithmatex">\(\mu\)</span> is a forward <span class="arithmatex">\(\alpha\)</span>-arrow, it could be of the forms </p>
<div class="arithmatex">\[
\alpha \quad 1_u \otimes \eta_1 \quad \eta_1\otimes 1_v
\]</div>
<p>with <span class="arithmatex">\(\eta_1\)</span> a forward <span class="arithmatex">\(\alpha\)</span>-arrow. Since <span class="arithmatex">\(\iota\)</span> 
is a forward unitor arrow, it could be of the forms </p>
<div class="arithmatex">\[
\lambda_v \quad \rho_u \quad 1_u \otimes \eta_2 \quad \eta_2\otimes 1_v
\]</div>
<p>with <span class="arithmatex">\(\eta_2\)</span> either a forward unitor arrow. 
We display our table below, this time coloring the entries 
in order to group together similar cases.</p>
<p>\begin{center}</p>
<table>
<thead>
<tr>
<th><span class="arithmatex">\((\mu,\iota)\)</span></th>
<th><span class="arithmatex">\(1_u\otimes \eta_2\)</span></th>
<th><span class="arithmatex">\(\eta_2 \otimes 1_v\)</span></th>
<th><span class="arithmatex">\(\lambda_v\)</span></th>
<th><span class="arithmatex">\(\rho_u\)</span> \ [0.2cm]  <span class="arithmatex">\(\alpha\)</span></th>
<th><span class="arithmatex">\(\textcolor{NavyBlue}{(\alpha_{u,s,t},1_u \otimes \eta_2)}\)</span></th>
<th><span class="arithmatex">\(\textcolor{NavyBlue}{(\alpha_{u,s,t}, \eta_2\otimes 1_v)}\)</span></th>
<th><span class="arithmatex">\(\textcolor{Orange}{(\alpha_{u,s,t}, \lambda_v)}\)</span></th>
<th><span class="arithmatex">\(\textcolor{Orange}{(\alpha_{u,s,t}, \rho_u)}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>0.2cm] <span class="arithmatex">\(1_u \otimes \eta_1\)</span></td>
<td><span class="arithmatex">\(\textcolor{Purple}{(1_u \otimes \eta_1 ,1_u \otimes \eta_2)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Purple}{(1_u \otimes \eta_1, \eta_2\otimes 1_v)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{ProcessBlue}{(1_u\otimes\eta_1 ,\lambda_v)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{ProcessBlue}{(1_u\otimes\eta_1 ,\rho_u)}\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0.2cm] <span class="arithmatex">\(\eta_1\otimes 1_v\)</span></td>
<td><span class="arithmatex">\(\textcolor{Purple}{(\eta_1\otimes 1_v ,1_u \otimes \eta_2)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Purple}{(\eta_1\otimes 1_v, \eta_2\otimes 1_v)}\)</span></td>
<td>$ \textcolor{ProcessBlue}{(\eta_1\otimes 1_v, \lambda_v)}$</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>\end{center}
\noindent </p>
<p>**Case 1: <span class="arithmatex">\((\alpha_{u,s,t**, 1_{u\otimes s} \otimes \eta_2)\)</span>}\
First consider <span class="arithmatex">\(\mu = \alpha_{u,s,t}: u\otimes(s\otimes t) \to (u \otimes s)\otimes t\)</span> 
and <span class="arithmatex">\(\iota = 1_{u\otimes s} \otimes \eta_2\)</span> with 
<span class="arithmatex">\(\eta_2: t \to t'\)</span> either a forward <span class="arithmatex">\(\lambda\)</span> or <span class="arithmatex">\(\rho\)</span> arrow.
We select the forward unitor arrow 
<span class="arithmatex">\(1_{u_A}\otimes(1_{s_A} \otimes (\eta_2)_A)\)</span> and the forward 
<span class="arithmatex">\(\alpha\)</span>-arrow <span class="arithmatex">\(\alpha_{u_A, s_A, t'_A}\)</span> to obtain the diagram </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_40.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which commutes by naturality of <span class="arithmatex">\(\alpha\)</span>. 
\
<strong>Case 2:</strong> <span class="arithmatex">\((\alpha_{u,s,t}, \eta_2 \otimes 1_t)\)</span>.\
In this case, <span class="arithmatex">\(\mu = \alpha_{u,s,t}: u\otimes(s\otimes t) \to (u\otimes s)\otimes t\)</span>, 
while <span class="arithmatex">\(\iota = \eta_2 \otimes 1_t\)</span>. Hence, <span class="arithmatex">\(\eta_2\)</span> must act on <span class="arithmatex">\((u \otimes s)\)</span>. 
With that said, 
<span class="arithmatex">\(\eta_2\)</span> must be of the form 
[
\lambda_s \qquad \rho_u \qquad \tau \otimes 1_s \qquad 1_u \otimes \sigma 
]</p>
<p>with <span class="arithmatex">\(\tau: u \to u'\)</span> and <span class="arithmatex">\(\sigma: s \to s'\)</span> either forward <span class="arithmatex">\(\lambda\)</span> or <span class="arithmatex">\(\rho\)</span> arrows. 
Thus we check each of these cases are satisfied. 
\
<strong>Case 2.1:</strong> <span class="arithmatex">\(\eta_2 = \lambda_{s_A}\)</span>\
In this case, <span class="arithmatex">\(u = I\)</span>. We can construct a triangular diagram 
by appending <span class="arithmatex">\(\lambda_{s_A \otimes t_A}: I \otimes (s_A \otimes t_A) \to s_A \otimes t_A\)</span> as 
below. </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_41.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which commutes in <span class="arithmatex">\(\mm\)</span> by Proposition \ref{proposition:unitor_diagrams}.
\
<strong>Case 2.2:</strong> <span class="arithmatex">\(\eta_2 = \rho_u\)</span>\
In this case, <span class="arithmatex">\(s_A = I\)</span>. We can append the morphism 
<span class="arithmatex">\(1_{u_A} \otimes \lambda_{t_A}: u_A \otimes (I \otimes t_A) \to u_A \otimes t_A\)</span> 
to create a triangular diagram as below. </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_42.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
The above diagram is guaranteed to commute by unitor-axiom (Diagram \ref{mon_definition_diag_2})
in any monoidal category <span class="arithmatex">\(\mm\)</span>.
\
<strong>Case 2.3:</strong> <span class="arithmatex">\(\eta_2 = \tau \otimes 1_s\)</span>\
In this case, <span class="arithmatex">\(\eta_2 = \tau \otimes 1_s\)</span> with <span class="arithmatex">\(\tau\)</span> a forward <span class="arithmatex">\(\lambda\)</span> 
or <span class="arithmatex">\(\rho\)</span>-arrow.
We can first apply the forward arrow <span class="arithmatex">\(\tau \otimes (1_{s_A} \otimes 1_{t_A})\)</span>
followed by <span class="arithmatex">\(\alpha_{u'_A, s_A, t_A}\)</span> to obtain the diagram </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_43.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/></p>
<p>which commutes by naturality of <span class="arithmatex">\(\alpha\)</span>. 
\
<strong>Case 2.4:</strong> <span class="arithmatex">\(\eta_2 = 1_u \otimes \sigma\)</span>. This case 
is nearly identical to the previous, creating a desired diagram 
which commutes by naturality of <span class="arithmatex">\(\alpha\)</span>. </p>
<p>This proves all of our cases for when <span class="arithmatex">\(\mu = \alpha_{u_A,s_A,t_A}\)</span> 
and <span class="arithmatex">\(\iota = (\eta_2)_A \otimes 1_{t_A}\)</span>, and so we move onto our other 
cases. 
\
<strong>Case 3:</strong> <span class="arithmatex">\((\alpha_{u,s,t}, \lambda_{t})\)</span>\
This case cannot happen, since we cannot apply <span class="arithmatex">\(\lambda: x_0 \otimes t \to x_0\)</span>
after <span class="arithmatex">\(\alpha_{u,s,t}: u\otimes (s\otimes t) 
\to (u \otimes s)\otimes t\)</span> as <span class="arithmatex">\(u \otimes s \ne x_0\)</span> for any binary words <span class="arithmatex">\(u, s\)</span>. 
\
<strong>Case 4:</strong> <span class="arithmatex">\((\alpha_{u,s,t}, \rho_{u\otimes s})\)</span>\
In this case, we'll have that <span class="arithmatex">\(\mu = \alpha_{u_A,s_A,t_A}\)</span> and 
<span class="arithmatex">\(\iota = \rho_{u_A \otimes s_A}\)</span>. This implies that 
<span class="arithmatex">\(t_A = I\)</span>. 
We can then append the forward <span class="arithmatex">\(\rho\)</span>-arrow <span class="arithmatex">\(1_{u_A}\otimes \rho_{s_A}\)</span> 
to obtain the diagram </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_44.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/></p>
<p>which we know commutes due to Proposition \ref{proposition:unitor_diagrams}.
\
<strong>Case 5:</strong> <span class="arithmatex">\((1_u \otimes \eta_1, 1_u \otimes \eta_2)\)</span>.
In this case <span class="arithmatex">\(\mu = 1_{u_A}\otimes (\eta_1)_A\)</span> and 
<span class="arithmatex">\(\iota = 1_{u_A}\otimes (\eta_2)_A\)</span> with <span class="arithmatex">\(\eta_1\)</span> a forward <span class="arithmatex">\(\alpha\)</span>-arrow 
and <span class="arithmatex">\(\eta_2\)</span> either a forward <span class="arithmatex">\(\lambda\)</span> or <span class="arithmatex">\(\rho\)</span>-arrow. 
We can prove this case by induction. </p>
<p>Suppose the statement 
is true for word of length less than <span class="arithmatex">\(n\)</span>, and let <span class="arithmatex">\(w = u\otimes v\)</span>
be a binary word of length <span class="arithmatex">\(n\)</span>. Then we have the diagram on the left</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_45.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which is the image of the diagram on the right under 
the functor <span class="arithmatex">\(u_A \otimes (-)\)</span>. By induction, there exists either a binary 
word <span class="arithmatex">\(z\)</span>, and a 
forward <span class="arithmatex">\(\lambda\)</span> or <span class="arithmatex">\(\rho\)</span> arrow <span class="arithmatex">\(\eta': v_A \to z\)</span> and 
a forward <span class="arithmatex">\(\alpha\)</span>-arrow <span class="arithmatex">\(\eta'': z \to v_A''\)</span> such that the diagram below commutes in 
<span class="arithmatex">\(\mm\)</span>. </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_46.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
We can then take the image of this under the functor <span class="arithmatex">\(u_A\otimes (-)\)</span> to obtain the 
commutative diagram below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_47.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
As <span class="arithmatex">\(1_{u_A} \otimes (\eta')_A\)</span> is a forward <span class="arithmatex">\(\lambda\)</span> or <span class="arithmatex">\(\rho\)</span> arrow 
since <span class="arithmatex">\((\eta')_A\)</span> is, and since <span class="arithmatex">\(1_{u_A} \otimes (\eta'')_A\)</span> is a forward 
<span class="arithmatex">\(\alpha\)</span>-arrow since <span class="arithmatex">\((\eta'')_A\)</span> is, we have that the case must be true 
for all words by induction. 
\
<strong>Case 6:</strong>  <span class="arithmatex">\((1_u \otimes \eta_1, \eta_2 \otimes 1_{v'})\)</span>\
In this case, <span class="arithmatex">\(\mu = 1_{u_A} \otimes (\eta_1)_A\)</span> with 
<span class="arithmatex">\(\eta_1: v \to v'\)</span> a forward <span class="arithmatex">\(\alpha\)</span>-arrow, and 
<span class="arithmatex">\(\iota = (\eta_2)_A \otimes 1_{v'}\)</span> with <span class="arithmatex">\(\eta_2: u \to u'\)</span> 
either a forward <span class="arithmatex">\(\lambda\)</span> or <span class="arithmatex">\(\rho\)</span> arrow. 
We can use the forward <span class="arithmatex">\(\lambda\)</span> or <span class="arithmatex">\(\rho\)</span> arrow 
<span class="arithmatex">\((\eta_2)_A \otimes 1_{v_A}\)</span> followed by the <span class="arithmatex">\(\alpha\)</span>-arrow 
<span class="arithmatex">\(1_{u'_A}\otimes (\eta_1)_A\)</span> to obtain the diagram below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_48.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
The above diagram commutes by functoriality of <span class="arithmatex">\(\otimes\)</span>, completing this case.
\
<strong>Case 7:</strong> <span class="arithmatex">\((1_u \otimes \eta_1, \lambda_{v'})\)</span>\
In this case we'll have <span class="arithmatex">\(\mu = 1_u \otimes \eta_1\)</span> with 
<span class="arithmatex">\(\eta_1\)</span> a forward <span class="arithmatex">\(\alpha\)</span>-arrow and <span class="arithmatex">\(\iota = \lambda_{v'}\)</span>. 
This then implies that <span class="arithmatex">\(u = I\)</span>. 
We can then append the <span class="arithmatex">\(\lambda\)</span>-arrow <span class="arithmatex">\(\lambda_{v_A}\)</span> followed 
by the <span class="arithmatex">\(\alpha\)</span>-arrow <span class="arithmatex">\((\eta_1)_A: v_A \to v'_A\)</span> to obtain the diagram</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_49.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which commutes by naturality of <span class="arithmatex">\(\lambda\)</span>. 
\
<strong>Case 8:</strong> <span class="arithmatex">\((1_u \otimes \eta_1, \rho_u)\)</span>\
This case cannot happen, since to apply <span class="arithmatex">\(\rho_u\)</span> after <span class="arithmatex">\(1_u \otimes \eta_1\)</span><br />
implies that the codomain of <span class="arithmatex">\(\eta_1\)</span> is <span class="arithmatex">\(x_0\)</span>, which is not possible if <span class="arithmatex">\(\eta_1\)</span> 
is an <span class="arithmatex">\(\alpha\)</span>-morphism. 
\
<strong>Case 9:</strong> <span class="arithmatex">\((\eta_1 \otimes 1_v, 1_u \otimes \eta_2)\)</span>\
Equivalent to <strong>Case 5</strong>.
\
<strong>Case 10:</strong> <span class="arithmatex">\((\eta_1\otimes 1_v, \eta_2\otimes 1_v)\)</span>\
Equivalent to <strong>Case 6</strong>.
\
<strong>Case 11:</strong><span class="arithmatex">\((\eta_1 \otimes 1_v, \lambda_v)\)</span>\
This case cannot happen, since to apply <span class="arithmatex">\(\lambda_v\)</span> after 
<span class="arithmatex">\(\eta_1 \otimes 1_v\)</span> implies that the codomain of <span class="arithmatex">\(\eta_1\)</span> is 
<span class="arithmatex">\(x_0\)</span>, which is not possible for an <span class="arithmatex">\(\alpha\)</span>-arrow. 
\
<strong>Case 12:</strong> <span class="arithmatex">\((\eta_1 \otimes 1_v, \rho_u)\)</span>\
In this case, we have that <span class="arithmatex">\(\mu = (\eta_1)_A \otimes 1_{v_A}\)</span> 
and <span class="arithmatex">\(\eta_2 = \rho_{u_A}\)</span>. This implies that 
<span class="arithmatex">\(v_A = I\)</span>. 
We can then append the forward <span class="arithmatex">\(\rho\)</span> arrow <span class="arithmatex">\(\rho_{u_A}\)</span> followed 
by the forward <span class="arithmatex">\(\alpha\)</span>-arrow <span class="arithmatex">\((\eta_1)_A\)</span> to the diagram to obtain </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_50.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which commutes by naturality of <span class="arithmatex">\(\rho\)</span>. </p>
<p>This proves all the cases, which completes the proof.
\end{varprf}</p>
<p>Thus we have proven the Associator-Unitor Swap. Our final task is to 
prove the Unitor-Chain Equivalence. To do so, it suffices to prove the following lemma. </p>
<p><span style="display:block" class="lemma">(Unitor Diamond Lemma.)
Let <span class="arithmatex">\(w\)</span> be a binary word, and <span class="arithmatex">\(\mu_1, \mu_2\)</span> a pair of forward unitor arrows 
as below. </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_51.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
There there exists a binary word <span class="arithmatex">\(z\)</span> and a pair
of forward unitor arrows 
<span class="arithmatex">\(\eta_1: w_1 \to z\)</span>, <span class="arithmatex">\(\eta_2: w_2 \to z\)</span> such that for any 
monoidal category <span class="arithmatex">\((\mm, \otimes, I, \alpha, \lambda, \rho)\)</span>, 
the diagram below is commutative in <span class="arithmatex">\(\mm\)</span>.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_52.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
</span></p>
<p>As before, we color the arrows which we are asserting to exist Green.</p>
<p><span style="display:block" class="proof">
To prove this, we do a case-by-case basis again. In general,  we will 
write <span class="arithmatex">\(w = u\otimes v\)</span>, and if <span class="arithmatex">\(\ll(v) &gt; 1\)</span>, we write <span class="arithmatex">\(w = u\otimes (s \otimes t)\)</span>. </p>
<p>Now since <span class="arithmatex">\(\mu_1, \mu_2\)</span> are forward unitor arrows, <span class="arithmatex">\(\mu_1\)</span> could be of the form </p>
<div class="arithmatex">\[
1_u \otimes \eta_1 \qquad \eta_1 \otimes 1_v \qquad \lambda_v \qquad \rho_u 
\]</div>
<p>while <span class="arithmatex">\(\mu_2\)</span> could be of the form </p>
<div class="arithmatex">\[
1_u \otimes \eta_2 \qquad \eta_2 \otimes 1_v \qquad \lambda_v \qquad \rho_u 
\]</div>
<p>with <span class="arithmatex">\(\eta_1, \eta_2\)</span> both forward unitor arrows.
Therefore, our possible cases are as follows.
We could have <span class="arithmatex">\(\mu_1 = \mu_2\)</span>. Or, we could have any of the cases below. 
The paired-coloring indicates logically equivalent cases
due to the symmetry of our problem. 
\begin{center}</p>
<table>
<thead>
<tr>
<th><span class="arithmatex">\((\beta_1,\beta_2)\)</span></th>
<th><span class="arithmatex">\(1_u\otimes \eta_2\)</span></th>
<th><span class="arithmatex">\(\eta_2 \otimes 1_v\)</span></th>
<th><span class="arithmatex">\(\lambda_v\)</span></th>
<th><span class="arithmatex">\(\rho_u\)</span> \ [0.2cm]  <span class="arithmatex">\(1_u \otimes \eta_1\)</span></th>
<th><span class="arithmatex">\(\textcolor{Orange}{(1_u \otimes \eta_1 ,1_u \otimes \eta_2)}\)</span></th>
<th><span class="arithmatex">\(\textcolor{ForestGreen}{(1_u \otimes \eta_1, \eta_2\otimes 1_v)}\)</span></th>
<th><span class="arithmatex">\(\textcolor{Purple}{(1_u\otimes\eta_1 ,\lambda_v)}\)</span></th>
<th><span class="arithmatex">\(\textcolor{red!80!White}{(1_u\otimes\eta_1 ,\rho_u)}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>0.2cm] <span class="arithmatex">\(\eta_1\otimes 1_v\)</span></td>
<td><span class="arithmatex">\(\textcolor{ForestGreen}{(\eta_1\otimes 1_v ,1_u \otimes \eta_2)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Orange}{(\eta_1\otimes 1_v, \eta_2\otimes 1_v)}\)</span></td>
<td>$ \textcolor{Magenta}{(\eta_1\otimes 1_v, \lambda_v)}$</td>
<td><span class="arithmatex">\(\textcolor{ProcessBlue}{(\eta_1\otimes 1_v, \rho_u)}\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0.2cm] <span class="arithmatex">\(\lambda_v\)</span></td>
<td><span class="arithmatex">\(\textcolor{Purple}{(\lambda_v ,1_u \otimes \eta_2)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Magenta}{(\lambda_v, \eta_2\otimes 1_v)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Blue}{(\lambda_v, \lambda_v)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Blue}{(\lambda_v, \rho_u)}\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0.2cm] <span class="arithmatex">\(\rho_u\)</span></td>
<td><span class="arithmatex">\(\textcolor{red!80!White}{(\rho_u ,1_u \otimes \eta_2)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{ProcessBlue}{(\rho_u, \eta_2\otimes 1_v)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Blue}{(\rho_u, \lambda_v)}\)</span></td>
<td><span class="arithmatex">\(\textcolor{Blue}{(\rho_u, \rho_u)}\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>\end{center}</p>
<p>Since we've already implemented this case-by-case proof strategy several times, 
we will point out the cases which we've seen before, and take care of the cases 
that are new. 
\
<strong>Case 1:</strong> <span class="arithmatex">\(\textcolor{Orange}{(1_u \otimes \eta_1 ,1_u \otimes \eta_2)}\)</span>
This case can be proven by induction on total length <span class="arithmatex">\(\ll(w) + \ee(w)\)</span>, using 
a similar argument as in Case 3 of Lemma \ref{lemma:diamond_lemma}.</p>
<p><strong>Case 2:</strong> <span class="arithmatex">\(\textcolor{ForestGreen}{(1_u \otimes \eta_1, \eta_2\otimes 1_v)}\)</span> 
This case can be proven via functoriality, in a similar manner as
Case 2 of Lemma \ref{lemma:diamond_lemma}.</p>
<p><strong>Case 3:</strong> <span class="arithmatex">\(\textcolor{Purple}{(1_u\otimes \eta_1, \lambda_v)}\)</span>.\
With <span class="arithmatex">\(\mu_1 = 1_u\otimes \eta_1\)</span> and <span class="arithmatex">\(\mu_2 = \lambda_v\)</span>, denote <span class="arithmatex">\(\eta_1: v \to v'\)</span>.
In this case, we can use the morphisms <span class="arithmatex">\(\lambda_{(v')_A}\)</span> and <span class="arithmatex">\(\eta_1\)</span> to obtain the 
diagram</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_53.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which commutes by naturality of <span class="arithmatex">\(\lambda\)</span>. 
\
<strong>Case 5:</strong> <span class="arithmatex">\(\textcolor{red!80!White}{(1_u\otimes\eta_1 ,\rho_u)}\)</span>.\
With <span class="arithmatex">\(\mu_1 = 1_u\otimes \eta_1, \mu_2 = \rho_u\)</span>, note that the only 
choice for  <span class="arithmatex">\(\eta_1\)</span> is <span class="arithmatex">\(\eta_1 = 1_{x_0}\)</span>. However, there is no unitor 
arrow with domain <span class="arithmatex">\(x_0\)</span>, so this does not result in a valid case for us to consider.
\
<strong>Case 6:</strong> <span class="arithmatex">\(\textcolor{Magenta}{(\eta_1\otimes 1_v, \lambda_v)}\)</span>.
\
With <span class="arithmatex">\(\mu_1 = \eta_1\otimes  1_v, \mu_2 = \lambda_v\)</span>, note that the  only 
choice for <span class="arithmatex">\(\eta_1\)</span> is again <span class="arithmatex">\(1_{x_0}\)</span>. Once again, there is no unitor arrow 
with domain <span class="arithmatex">\(x_0\)</span>, so this is also not a valid case that we need to consider.
\
<strong>Case 7:</strong> <span class="arithmatex">\(\textcolor{ProcessBlue}{(\eta_1 \otimes 1_v, \rho_u)}\)</span>.
\
With <span class="arithmatex">\(\mu_1 = \eta_1\otimes 1_v, \mu_2 = \rho_u\)</span>, we can use the morphisms 
<span class="arithmatex">\(\rho_{(u')_A}\)</span> and <span class="arithmatex">\(\eta_1\)</span> to obtain </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_54.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
which commutes by naturality of <span class="arithmatex">\(\rho\)</span>. </p>
<p><strong>Case 8:</strong> <span class="arithmatex">\(\textcolor{Blue}{(\lambda_v, \lambda_v)}\)</span>. 
In this case, we see that <span class="arithmatex">\(\mu_1 = \mu_2\)</span>, so that the statement is trivially 
satisfied in this case. </p>
<p>With all cases verified, we see that the statement must be true for all 
binary words, as desired. 
</span></p>
<p>We now show how this proves the Unitor-Chain Equivalence, which we restate 
for the readers convenience. </p>
<p><span style="display:block" class="proposition">[Unitor-Chain Equivalence]
Let <span class="arithmatex">\(w\)</span> be a binary word with nonzero length and with <span class="arithmatex">\(\ee(w) = k\)</span>. 
Suppose <span class="arithmatex">\(\mu_1, \dots, \mu_k\)</span> and <span class="arithmatex">\(\eta_1, \dots, \eta_k\)</span> are forward 
unitors and that:
[
\mu_k \circ \cdots \circ \mu_1, \; \eta_k \circ \cdots \circ \eta_1: w \to \overline{w}
]</p>
<p>Then <span class="arithmatex">\((\mu_k)_A \circ \cdots \circ (\mu_1)_A =  (\eta_k)_A \circ \cdots \circ (\eta_1)_A\)</span>
in <span class="arithmatex">\(\mm\)</span>.
</span></p>
<p><span style="display:block" class="proof">
We prove this by induction on <span class="arithmatex">\(\ee(w)\)</span>. Suppose the result is true for 
binary words <span class="arithmatex">\(v\)</span> with <span class="arithmatex">\(\ee(v) &lt; \ee(w)\)</span>, and consider two composable 
chains of forward unitors <span class="arithmatex">\(\mu_1, \dots, \mu_k, \eta_1, \dots, \eta_k\)</span> 
as described above. We seek to show that the diagram </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_55.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
is commutative in <span class="arithmatex">\(\mm\)</span>. By the Unitor Diamond Lemma, there exists a binary 
word <span class="arithmatex">\(z\)</span> and two forward unitors <span class="arithmatex">\(\iota_1: u \to z\)</span> and <span class="arithmatex">\(\iota_2: v \to z\)</span> 
such that </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_56.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
is commutative in <span class="arithmatex">\(\mm\)</span>. Now, by Lemma \ref{lemma:unitors_preserve_clean_word}, 
we have that 
<span class="arithmatex">\(\overline{z} = \overline{w}\)</span>. By Lemma \ref{lemma:unitors_decrease_unit_length}, 
<span class="arithmatex">\(\ee(z) = k - 2\)</span>.
Hence, by Proposition \ref{proposition:exists_w_to_clean_w}, 
there exists a chain of forward unitors <span class="arithmatex">\(\nu_1, \dots, \nu_{k-2}\)</span> 
such that <span class="arithmatex">\(\nu_{k-2} \circ \cdots \circ \nu_1: z \to \overline{w}\)</span>.
Our situation is displayed below. For clarity, we suppress <span class="arithmatex">\(\nu_{k-2} \circ \cdots \circ \nu_1: z \to \overline{w}\)</span> 
in the diagram below.</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_57.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
By Lemma \ref{lemma:unitors_decrease_unit_length}, we know that 
<span class="arithmatex">\(\ee(u_1), \ee(v_1) &lt; \ee(w)\)</span>. Therefore, we may apply our induction 
hypothesis to conclude that the lower left and lower right triangles must 
commute. As the original upper square commutes by the Unitor Diamond Lemma, 
this implies that </p>
<div class="arithmatex">\[
(\mu_k)_A \circ \cdots \circ (\mu_1)_A 
=
(\eta_k)_A \circ \cdots \circ (\eta_2)_A
\]</div>
<p>as desired. 
</span></p>
<p>At this point, we have formally filled in all of the potential gaps in the proof 
of Theorem \ref{theorem:coherence_in_unitors}. We have completed the
hard work required to prove Mac Lane's Coherence Theorem. We will use the next section 
to see how our previous results immediately apply our desired coherence result.</p>
<p>\subsection*{Step Seven: Proving the Main Theorem}</p>
<p>At this point we have proven coherence in associators and unitors, but 
only when considering iterated monoidal products of a single object. 
We have not yet achieved our desired result, which should say something 
about more general monoidal products with different objects in the expression. 
However, our previous work quickly implies our desired theorem. We first introduce 
a definition and perform a clever trick. </p>
<p>In what follows, we let <span class="arithmatex">\(**1**\)</span> denote the terminal category 
whose sole object is denoted <span class="arithmatex">\(\bullet\)</span>.</p>
<p><span style="display:block" class="definition">
Let <span class="arithmatex">\((\mm, \otimes, I)\)</span> be a monoidal category. 
Define the <strong>iterated functor category\footnote{The notation of this category 
is due to Mac Lane, but he did not supply a name for this category.
So I made one up. Today, this construction is known as an endomorphism 
operad.</strong> of <span class="arithmatex">\(\mm\)</span>}, denoted as
<span class="arithmatex">\(**It**(\mathcal{M})\)</span>, to be the category where:</p>
<ul>
<li><strong>Objects.</strong> Functors <span class="arithmatex">\(F: \mathcal{M}^n \to \mathcal{M}\)</span> for all <span class="arithmatex">\(n = 0, 1, 2, \dots\)</span>
When <span class="arithmatex">\(n = 0\)</span>, we let <span class="arithmatex">\(\mm^0 = **1**\)</span>.</li>
<li><strong>Morphisms.</strong> Natural transformations <span class="arithmatex">\(\eta: F \to G\)</span> between such functors.</li>
</ul>
<p></span></p>
<p>We will give this category a monoidal structure.
Towards that goal, we introduce the following bifunctor</p>
<div class="arithmatex">\[
\odot : **It**(\mathcal{M})\times **It**(\mathcal{M}) \to 
**It**(\mathcal{M})
\]</div>
<p>whose behavior we describe on objects and morphisms as follows. </p>
<ul>
<li><strong>On objects.</strong> For two functors <span class="arithmatex">\(F: \mm^n \to \mm\)</span>, <span class="arithmatex">\(G: \mm^m \to \mm\)</span>, 
we define the functor <span class="arithmatex">\(F \odot G: \mm^{n+m} \to \mm\)</span> pointwise as </li>
</ul>
<div class="arithmatex">\[
(F \odot G)(A_1, \dots, A_{n+m})
= 
F(A_1, \dots, A_n) \otimes G(A_{n+1}, \dots, A_{n+m})
\]</div>
<p>where <span class="arithmatex">\(\otimes\)</span> is the monoidal product of <span class="arithmatex">\(\mm\)</span>.
* <strong>On morphisms.</strong> Let <span class="arithmatex">\(F_1, G_1: \mm^n \to \mm\)</span> and <span class="arithmatex">\(F_2, G_2: \mm^m \to \mm\)</span>. 
Given natural transformations </p>
<div class="arithmatex">\[
\eta: F_1 \to G_1 \qquad \mu: F_2 \to G_2
\]</div>
<p>we define the natural transformation <span class="arithmatex">\(\eta \odot \mu: F_1 \odot G_1 \to F_2 \odot G_2\)</span> 
pointwise as</p>
<div class="arithmatex">\[
(\eta \odot \mu)_{(A_1, \dots, A_{n+m})} = (\eta)_{(A_1, \dots, A_n)} \otimes (\mu)_{(A_{n+1}, \dots, A_{n+m})}
\]</div>
<p>The above bifunctor is what allows us to regard <span class="arithmatex">\(**It**(\mm)\)</span> as a monoidal 
category. This is more precisely stated in the following lemma.</p>
<p><span style="display:block" class="lemma">
Let <span class="arithmatex">\((\mathcal{M}, \otimes, I, \alpha, \lambda, \rho)\)</span> be a monoidal category. 
Then </p>
<div class="arithmatex">\[
\left(**It**(\mm), \odot, c, \bm{\alpha}, \bm{\lambda}, \bm{\rho}\right)
\]</div>
<p>is a monoidal category where </p>
<ul>
<li>The monoidal product is the bifunctor
<span class="arithmatex">\(\odot: **It**(\mathcal{M})\times **It**(\mathcal{M}) \to 
**It**(\mathcal{M})\)</span></li>
<li>The identity object is the functor <span class="arithmatex">\(c: **1** \to \mm\)</span>, where <span class="arithmatex">\(c(\bullet) = I\)</span></li>
<li>For functors <span class="arithmatex">\(F_j: \mm^{i_j} \to \mm\)</span>, <span class="arithmatex">\(j = 1, 2, 3\)</span>, the associator </li>
</ul>
<div class="arithmatex">\[
\bm{\alpha}_{F_1, F_2, F_3}: F_1 \odot (F_2 \odot F_3) \to (F_1 \odot F_2) \odot F_3
\]</div>
<p>is the natural transformation defined pointwise for each <span class="arithmatex">\((A_1, \dots, A_{i_1 + i_2 + i_3}) \in 
\mm^{(i_1 + i_2 + i_3)}\)</span> as </p>
<p>[
(\bm{\alpha}<em>{F_1, F_2, F_3})</em>{(A_1, \dots, A_{i_1 + i_2 + i_3})}
=
\alpha_{(F(A_1, \dots, A_{i_1}), F(A_{i_1 + 1}, \dots A_{i_1 + i_2}), F(A_{i_1 + i_2 + 1}, \dots, A_{i_1 + i_2 + i_3}))}
]
* For a functor <span class="arithmatex">\(F: \mm^n \to \mm\)</span>, the left unitor <span class="arithmatex">\(\bm{\lambda}: c \odot F \to F\)</span> 
is the natural transformation defined pointwise for <span class="arithmatex">\((\bullet, A_1, \dots, A_n) \in **1**\times \mm^{n}\)</span> as </p>
<div class="arithmatex">\[
(\bm{\lambda}_F)_{(\bullet, A_1, \dots, A_n)} = \lambda_{F(A_1, \dots, A_n)}
\]</div>
<p>while the right unitor <span class="arithmatex">\(\bm{\rho}: F \odot c \to F\)</span> 
is the natural transformation defined similarly as</p>
<div class="arithmatex">\[
(\bm{\rho}_F)_{(A_1, \dots, A_n, \bullet)} = \rho_{F(A_1, \dots, A_n)}
\]</div>
<p></span></p>
<p>It is simple to check that these satisfy the axioms of a monoidal category. 
We now reach the final theorem.</p>
<p><span style="display:block" class="theorem">[Coherence Theorem for Monoidal Categories.]
For every monoidal category <span class="arithmatex">\(\mm\)</span>, there exists a unique, 
strict monoidal functor </p>
<div class="arithmatex">\[
\Phi_{\text{\small id}}: \ww \to **It**(\mm)
\]</div>
<p>where <span class="arithmatex">\(\Phi_{\text{\small id}}(x_1) = \id: \mm \to \mm\)</span>.</p>
<p></span></p>
<p><span style="display:block" class="proof">
As <span class="arithmatex">\((**It**(\mm), \odot, c)\)</span> is a monoidal category by Lemma 
\ref{lemma:IT_is_monoidal}, the theorem follows by a simple
application of Theorem \ref{theorem:coherence_in_unitors} to this 
monoidal category.
</span></p>
<p>A reader might be wondering: How does the above theorem grant us coherence? 
Let us first investigate the behavior of this functor. </p>
<p>Under the functor, the morphism in <span class="arithmatex">\(\ww\)</span> </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_58.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
is mapped by <span class="arithmatex">\(\Phi_{\id}\)</span> to the natural transformation between the functors in <span class="arithmatex">\(**It**(\mm)\)</span></p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_59.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
and, as functors from <span class="arithmatex">\(\mm^3 \to \mm\)</span>, 
we may substitute any <span class="arithmatex">\(A,B,C\)</span> to obtain a natural isomorphism </p>
<div class="arithmatex">\[
\alpha_{A,B,C}: A \otimes (B \otimes C) \to (A \otimes B)\otimes C
\]</div>
<p>in <span class="arithmatex">\(\mm\)</span>.
Next, we know that functors preserve diagrams. Therefore, our commutative 
pentagon diagram in <span class="arithmatex">\(\ww\)</span></p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_60.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
is mapped by <span class="arithmatex">\(\Phi_{\id}\)</span> to a commutative 
diagram of natural transformations in <span class="arithmatex">\(**It**(\mm)\)</span> 
between the functors below</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_61.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
and as the above functors are of the form <span class="arithmatex">\(\mm^4 \to \mm\)</span>,
we may substitute any <span class="arithmatex">\(A,B,C,D \in \mm\)</span> to obtain the commutative diagram </p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_62.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
in <span class="arithmatex">\(\mm\)</span>. </p>
<p>So far, our functor makes sense. Moreover, we already knew that the above pentagon commutes 
for all <span class="arithmatex">\(A,B,C,D \in \mm\)</span>. Thus, what about diagram \ref{diagram:assoc_5}?</p>
<p>Again, functors preserve diagrams. Therefore, the commutative 
diagram in <span class="arithmatex">\(\ww\)</span> (see next page)
is mapped by <span class="arithmatex">\(\Phi_{\id}\)</span> to the commutative 
diagram of natural transformations in <span class="arithmatex">\(**It**(\mm)\)</span>
between functors (see second page)
and as functors from <span class="arithmatex">\(\mm^5 \to \mm\)</span>, we may substitute any <span class="arithmatex">\(A,B,C,D,E\)</span> to obtain the 
commutative diagram in <span class="arithmatex">\(\mm\)</span> (on the third page).</p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_63.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/></p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_64.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/></p>
<p><img src="../../../png/category_theory/chapter_7/tikz_code_4_65.png" width="99%" style="display: block; margin-left: auto; margin-right: auto;"/>
This process continues for every possible diagram in <span class="arithmatex">\(\ww\)</span>. 
Each diagram in <span class="arithmatex">\(\ww\)</span> is mapped to a corresponding diagram 
in <span class="arithmatex">\(**It**(\mm)\)</span> made up of identity functors, and 
with the identity functor, we are free to substitute whatever instance 
of <span class="arithmatex">\(A, B, C, \dots \in M\)</span> in it. The arrows between the identity functors 
are natural transformations which reduce to instances of <span class="arithmatex">\(\alpha, \rho, \lambda\)</span> in
<span class="arithmatex">\(\mm\)</span> upon substituting objects in the identity functor. 
What matters here is the functoriality of <span class="arithmatex">\(\Phi_I\)</span>.
It guarantees that all the diagrams obtained as the image of <span class="arithmatex">\(\Phi_{\text{\small id}}\)</span> 
will commute. </p>
<p>This completes our work towards proving Mac Lane's Coherence Theorem.</p>
<script src="../../mathjax_helper.js"></script>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "navigation.expand", "navigation.tabs"], "search": "../../../assets/javascripts/workers/search.a264c092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.726fbb30.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
      
    
  </body>
</html>