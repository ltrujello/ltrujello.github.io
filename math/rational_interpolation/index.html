<!DOCTYPE html>
<html>
<head>
    <title>Luke Trujillo</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" type="text/css" href="/css/styles.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    <link rel="icon" type="image/png" href="/imgs/favicon.png">
    <link rel="stylesheet" type="text/css" href="/css/code.css"/>
	
    
    <!-- Mathjax stuff -->
    <script>
        MathJax = {
        tex: {
            inlineMath: [['$', '$']]
        }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body class="main">
    <img class="img_header" src="/imgs/IMG_1975.jpg" alt="Some mountain">
    <div>
    <h2 class="left-banner"> <a style="color:black" href="/"> Hello, world! </a> </h2>
    <ul class="nav-bar">
        <li><a href="/"> Home </a></li>
        <li><a href="/cs/tikzpy/"> TikzPy </a></li>
        <li><a href="/math/associahedron/"> Associahedron </a></li>
        <li><a href="/cs/programming_idioms/"> Programming Idioms </a></li>
        <li><a href="/about/"> About </a></li>
    </ul>
    </div>
<div class="main-content">
<article>
<h1><a href="/math/rational_interpolation/">Rational Interpolation</a></h1>
<p>I recently uncovered a hidden gem when it comes to literature on rational interpolation. It's this PhD thesis by someone named Antonio Cosmin Ionita titled <em>Lagrange rational interpolation and its applications to approximation of large-scale dynamical systems</em>. I've found that finding good resources on rational interpolation is really hard, so this is a great resource.</p>
<p>It turns out that interpolating a set of coordinates with a rational function gives a much better approximation than with a polynomial interpolation. Additionally, for some datasets, a <em>unique</em> rational interpolant exists. This is the case with polynomial interpolation, but it's surprising that this would extend to the rational case because rational polynomials are much more complex. </p>
<h2>Background</h2>
<p>The idea is that one has a dataset of the form $(x_i, f_i)$ with $i = 0, 1, 2, \dots, N$, and you would like to interpolate the data with some rational function.</p>
<p>In the polynomial case, the way that you solve this is by using a family of functions known as the <strong>Lagrange Polynomials</strong>. Given a a set of data $(x_i, f_i)$, the Lagrange polynomials are the polynomials
\begin{align}
    \ell_0(x) &amp;= (x - x_1)(x - x_2)\cdots (x - x_N) = \prod_{i \ne 1}^{N}(x - x_i)\\
    \ell_1(x) &amp;= (x - x_0)(x - x_2)\cdots (x - x_N) = \prod_{i \ne 2}^{N}(x - x_i)\\
    \vdots    &amp;= \vdots \\
    \ell_N(x) &amp;= (x - x_0)(x - x_1)\cdots (x - x_{N-1}) = \prod_{i \ne N}^{N}(x - x_i)
\end{align}
One then observes that the polynomial of degree $N$
$$
    p(x) = \sum_{i = 1}^{N} \frac{f_i}{\ell_i(x_i)}\cdot \ell_i(x)
$$ 
interpolates the data. Note the linear algebra interpretation: $\frac{f_i}{\ell_i(x_i)}$ can be regarded as the coefficient and $\ell_i(x)$ as the basis vector.</p>
<p>For example, consider 20 points on $y = \sin(x)$ equidistantly spaced on $[0, 2\pi]$. We can perform lagrange interpolation, and see how the interpolation behaves in the range $[-3, 2\pi + 3]$.</p>
<p><img alt="alt text" src="/math/rational_interpolation/imgs/lagrange_poly.png" /></p>
<p>The polynomial interpolation does a good job on the assigned interval, but deviates very quickly outside.</p>
<p>In practice, it is easier to use the <strong>Barycentric</strong> form of the interpolation, since it requires less computational operations. It also turns out to be the right way to think about Lagrange interpolation.Before we introduce that form we need a small fact.</p>
<p><strong>Lemma:</strong> Let $\ell_i(x)$ be the $i$-th lagrange basis vector for a dataset $(x_i, f_i)$ for $i = 0, 1, 2, \dots, N$. Then 
$$e(x) = \sum_{i = 0}^{N}\frac{1}{\ell_i(x_i)}\ell_i(x) = 1$$</p>
<p><strong>Proof:</strong> Consider the polynomial $q(x) = e(x) - 1$. Since $e(x_i) = 1$, we see that each $x_i$ is a root of $q(x)$, and so $q(x)$ has $N + 1$ many distinct roots. However, $q(x)$ is a polynmoial of degree at most $N$. Therefore $q(x) = 0$.</p>
<p>Using the above result, we can now write
\begin{align}
p(x) = \frac{p(x)}{e(x)}
= \frac{\sum_{i = 0}^{N} \frac{f_i}{\ell_i(x_i)}\cdot \ell_i(x)}{\sum_{i = 0}^{N} \frac{1}{\ell_i(x_i)}\cdot \ell_i(x) }
= \frac{\ell(x) \cdot \sum_{i = 0}^{N}\frac{f_i}{\ell_i(x_i)}\cdot \frac{1}{x - x_i}}{\ell(x) \cdot \sum_{i = 0}^{N}\frac{1}{\ell_i(x_i)}\cdot \frac{1}{x - x_i}}\
\end{align}
where $\ell(x) = \prod_{i = 0}^{N}(x - x_i)$. So to reiterate, we just used the fact that
$\ell_i(x) = \frac{1}{x - x_i}\ell(x)$ and then factored and cancelled out $\ell(x)$ from the expression. This gives the <strong>Barycentric form</strong> of polynomial Lagrange interpolation:
$$
p(x) = \frac{\sum_{i = 0}^{N}\dfrac{f_i}{\ell_i(x_i)} \dfrac{1}{x - x_i}}{\sum_{i = 0}^{N}\dfrac{1}{\ell_i(x_i)} \dfrac{1}{x - x_i}}
$$
Note that we can't plug in $x_i$, but that's okay because we already know the value should be $f_i$. This can be easily coded into a program.</p>
<h2>Code</h2>
<p>To begin, we first need some imports. Unlike a lot of code tutorials that randomly import modules in the middle of program bodies (which is bad), we're going to import things once and for all right here.
Note that we don't really need much for this.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">matrix_rank</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">null_space</span>
</code></pre></div>

<p>We first need a simple function to partition our data. Cosmin-Ionita recommends alternate paritioning for best numerical results, so we do that here.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">alternating_partition</span><span class="p">(</span><span class="n">xy_data</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span> <span class="n">left_arr_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Creates a disjoint partition of the xy_data, one parition being of size left_arr_size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lambda_data</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Left array x_data</span>
    <span class="n">w_data</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Left array y_data</span>
    <span class="n">mu_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">v_data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">left_arr_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">left_arr_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy_data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">left_arr_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy_data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot alternately select </span><span class="si">{</span><span class="n">left_arr_size</span><span class="si">}</span><span class="s2"> many points from xy_data&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xy_data</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pt</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">left_arr_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lambda_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">w_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">left_arr_size</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">v_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lambda_data</span><span class="p">,</span> <span class="n">w_data</span><span class="p">,</span> <span class="n">mu_data</span><span class="p">,</span> <span class="n">v_data</span>
</code></pre></div>

<p>Next we need to actually code the Loewner matrix. This requires the partitioning function, which is why we introduced it first. Here it is.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">loewner_matrix</span><span class="p">(</span><span class="n">x_data</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">y_data</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Consider  x_data = [x_1, x_2, ..., x_n] with y_data = [y_1, ..., y_n]</span>
<span class="sd">    The function </span>
<span class="sd">        1. Creates two disjoint partitions of x_data</span>
<span class="sd">            [mu_1, ..., mu_{n_1}], [lambda_1, ..., lambda_{n_2}]</span>
<span class="sd">        and corresponding disjoint partitions of y_data </span>
<span class="sd">            [v_1, ..., v_{n_1}], [w_1, ..., w_{n_2}]</span>
<span class="sd">        2. Calculates the Loewner matrix defined as </span>
<span class="sd">                        v_i - w_j</span>
<span class="sd">            L_{ij} = ---------------</span>
<span class="sd">                    mu_i - lambda_j</span>
<span class="sd">        3. Calculates the smaller Loewner matrix, based on rank(L_ij)</span>
<span class="sd">    and returns the nullspace of this smaller matrix. </span>
<span class="sd">    For more details, see Algorithm 1.1, P. 33 of [Cosmin-Ionita].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="s2">&quot;input x and y data are mismatched&quot;</span>
    <span class="c1"># Patition the data</span>
    <span class="n">xy_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">))</span>
    <span class="n">lambda_data</span><span class="p">,</span> <span class="n">w_data</span><span class="p">,</span> <span class="n">mu_data</span><span class="p">,</span> <span class="n">v_data</span> <span class="o">=</span> <span class="n">alternating_partition</span><span class="p">(</span><span class="n">xy_data</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu_data</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_data</span><span class="p">)</span>

    <span class="c1"># Calculate the loewner matrix</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v_data</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">w_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">w_data</span><span class="p">):</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_i</span> <span class="o">-</span> <span class="n">w_j</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lambda_data</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="c1"># Calculate the smaller Loewner matrix, based on rank of L</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">matrix_rank</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">L_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-</span> <span class="p">(</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-</span> <span class="p">(</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">lambda_hat</span><span class="p">,</span> <span class="n">w_hat</span><span class="p">,</span> <span class="n">mu_hat</span><span class="p">,</span> <span class="n">v_hat</span> <span class="o">=</span> <span class="n">alternating_partition</span><span class="p">(</span><span class="n">xy_data</span><span class="p">,</span> <span class="n">left_arr_size</span><span class="o">=</span><span class="n">rank</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v_hat</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">w_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">w_hat</span><span class="p">):</span>
            <span class="n">L_hat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_i</span> <span class="o">-</span> <span class="n">w_j</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu_hat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lambda_hat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">null_space</span><span class="p">(</span><span class="n">L_hat</span><span class="p">),</span> <span class="n">lambda_hat</span><span class="p">,</span> <span class="n">w_hat</span>
</code></pre></div>

<p>We now write the code for the rational interpolater. This is a function that returns a function, because Python is amazing and lets you do that. The function it returns is the rational interpolator.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">rational_interpolant</span><span class="p">(</span><span class="n">x_data</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">y_data</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns a rational function that interpolates the xy data.&quot;&quot;&quot;</span>
    <span class="c1"># Compute the loewner matrix, nullspace</span>
    <span class="n">nullspace</span><span class="p">,</span> <span class="n">lambda_hat</span><span class="p">,</span> <span class="n">w_hat</span> <span class="o">=</span> <span class="n">loewner_matrix</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>
    <span class="n">nullspace_vec</span> <span class="o">=</span> <span class="n">nullspace</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_hat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">w_hat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nullspace_vec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interpolant</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y_data</span><span class="p">[</span><span class="n">x_data</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_hat</span><span class="p">)</span>
        <span class="n">numer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
            <span class="n">a_i</span> <span class="o">=</span> <span class="n">nullspace_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">w_i</span> <span class="o">=</span> <span class="n">w_hat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">lambda_i</span> <span class="o">=</span> <span class="n">lambda_hat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">numer</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a_i</span> <span class="o">*</span> <span class="n">w_i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">lambda_i</span><span class="p">)</span>
            <span class="n">denom</span> <span class="o">+=</span> <span class="n">a_i</span><span class="o">/</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">lambda_i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">numer</span><span class="o">/</span><span class="n">denom</span>

    <span class="k">return</span> <span class="n">interpolant</span>
</code></pre></div>

<p>Finally, we need some code to usefully view our rational interpolation and the original function. We do this by coloring our points, which requires its own function. One thing we have to be careful with is that rational functions naturally have poles, so we need to tip toe around those coordinates. We do so with a <code>try</code> statement.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_colors</span><span class="p">(</span><span class="n">y_1</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">y_2</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Given values y_1 which approximate values y_2, we return a list of RGB values </span>
<span class="sd">    ranging from blue to orange to communicate approximation error</span>
<span class="sd">    Blue indicates no error, orange indicates bad error.&quot;&quot;&quot;</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Maximum y_1 - y_2 difference to use a fully orange color</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_1</span><span class="p">)):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">thresh</span> <span class="o">-</span> <span class="n">diff</span><span class="p">)</span><span class="o">/</span><span class="n">thresh</span>

        <span class="n">R</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">B</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="n">scale</span>
        <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">R</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span><span class="n">G</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span><span class="n">B</span><span class="o">/</span><span class="mi">255</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">colors</span>

<span class="k">def</span> <span class="nf">plot_interpolater</span><span class="p">(</span><span class="n">x_test</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">interpolater</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Test and plot the behavior of the interpolater and the function on x_test.&quot;&quot;&quot;</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x_test_defined</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># We collect and leave out values that the function is not defined at</span>
    <span class="k">for</span> <span class="n">x_val</span> <span class="ow">in</span> <span class="n">x_test</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">y_val</span> <span class="o">=</span> <span class="n">interpolater</span><span class="p">(</span><span class="n">x_val</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_test_defined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_val</span><span class="p">)</span>
            <span class="n">y_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_val</span><span class="p">)</span>

    <span class="c1"># Collect the function data for this test set of x values</span>
    <span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">x_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">x_val</span> <span class="ow">in</span> <span class="n">x_test_defined</span><span class="p">]</span>

    <span class="c1"># Now we plot the defined x_vals and the y_vals</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">generate_colors</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_test_defined</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_test_defined</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</code></pre></div>

<p>This leads to our final wrapper function which conviently processes all of our previous functions.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">interpolate_and_plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="c1"># Calculate true data</span>
    <span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">]</span>

    <span class="c1"># Compute the rational interpolant</span>
    <span class="n">rat</span> <span class="o">=</span> <span class="n">rational_interpolant</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>
    <span class="n">plot_interpolater</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">rat</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>

<h2>Some runs</h2>
<p>The first test that Cosmin-Ionita performs is an attempt to model points selected from the curve 
$$
f(x) = \frac{1}{1 + 100(x + 1/2)^2} + \frac{1}{1 + 100(x-1/2)^2}.
$$
We can test rationally interpolating 100 points in the interval $[-1, 1]$:</p>
<div class="codehilite"><pre><span></span><code><span class="n">x_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">100</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="n">interpolate_and_plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>

<p>which gives
<img alt="alt text" src="/math/rational_interpolation/imgs/double_peak.png" /></p>
<p>It looks pretty good. Let's try another rational function:
$$
    f(x) = \frac{4}{8x + 1} - \frac{2}{8x + 4} - \frac{1}{8x + 5} - \frac{1}{8x + 6}
$$
The code to interpolate 100 points within $[-1, 1]$ is </p>
<div class="codehilite"><pre><span></span><code><span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)]</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">4</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span>

<span class="n">interpolate_and_plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>

<p>We can view the results here.
<img alt="alt text" src="/math/rational_interpolation/imgs/4_poles.png" /></p>
<p>This also does pretty well, and it handles the numerous singularities nicely, as it captures the overall behavior near the poles.</p>
<h2>Tests</h2>
<p>Let's now see how the interpolation performs outside of the range of interpolation.</p>
<p>In our first example when we discussed interpolation via polynomials, we showed how it performed on $f(x) = \sin(x)$ with 50 points sampled on $[0, 2\pi]$. Let's do the same thing with rational interpolation and see how it performs on $[-(2\pi + 5), 2\pi + 5]$. The code to do this is </p>
<div class="codehilite"><pre><span></span><code><span class="n">x_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">]</span>

<span class="n">rat</span> <span class="o">=</span> <span class="n">rational_interpolant</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">x_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_interpolater</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">rat</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>

<p>which gives the result
<img alt="alt text" src="/math/rational_interpolation/imgs/sin.png" /></p>
<p>This is a huge improvement compared to polynomial interpolation. This captures a few periods outside of the original range.</p>
<p>Let's try the rational function $f(x) = \frac{1}{1 + 100(x + 1/2)^2} + \frac{1}{1 + 100(x-1/2)^2}.$
again and look at the performance on $[-3, 3]$. The code to do this is as follows.</p>
<div class="codehilite"><pre><span></span><code><span class="n">x_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">]</span>
<span class="n">rat</span> <span class="o">=</span> <span class="n">rational_interpolant</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>

<span class="c1"># Test data</span>
<span class="n">x_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>

<span class="n">plot_interpolater</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">rat</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>

<p>In this case it looks like it found the actual rational function it was assigned to interpolate. 
<img alt="alt text" src="/math/rational_interpolation/imgs/double_peak_test.png" /></p>
<p>We can try this on the second example from before, similarly on [-3, 3]</p>
<div class="codehilite"><pre><span></span><code><span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)]</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">4</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span>

<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">]</span>

<span class="c1"># Test data</span>
<span class="n">x_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>

<span class="n">plot_interpolater</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">rat</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>

<p>This also looks like it converged to the actual function.
<img alt="alt text" src="/math/rational_interpolation/imgs/4_poles_test.png" /></p>
<p>Now let's take a function which is not rational, $f(x) = e^x$. Let's interpolate 20 points in $[0, 1]$.
The code to do that is </p>
<div class="codehilite"><pre><span></span><code><span class="n">x_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">]</span>

<span class="n">rat</span> <span class="o">=</span> <span class="n">rational_interpolant</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="o">**</span><span class="n">x</span>

<span class="n">x_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

<span class="n">plot_interpolater</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">rat</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>

<p>Note that we're seeing how the interpolation performs on $[0, 5]$.
<img alt="alt text" src="/math/rational_interpolation/imgs/exponential_20_pts.png" /></p>
<p>Now what is interesting is if we interpolate more points in in $[0, 1]$, say 50 instead of 20, then we actually get worse performance on $[0, 5]$! The code</p>
<div class="codehilite"><pre><span></span><code><span class="n">x_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">]</span>

<span class="n">rat</span> <span class="o">=</span> <span class="n">rational_interpolant</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="o">**</span><span class="n">x</span>

<span class="n">x_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

<span class="n">plot_interpolater</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">rat</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>

<p>gives
<img alt="alt text" src="/math/rational_interpolation/imgs/exponential_50_pts.png" />
Thus rational interpolation is subject to overfitting fallacies just like any approximation model. </p>
</article>

</div>

</body>
</html>
